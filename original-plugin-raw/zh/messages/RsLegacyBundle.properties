0.1={0}\:\:{1}
0.2.choice.0.is.in.progress.1.on.the.fly.analysis.is.turned.1={0}{2, choice, 0\# 正在进行|1\# 即时分析已\: {1}}
0.abi={0} ABI
0.for.1={1} 的 {0}
0.lines.covered=已覆盖 {0}% 的行
0.naming.convention={0}命名约定
0.of.1.files={0}/{1} 个文件
0.of.1.files.covered=已覆盖 {0}/{1} 个文件
0.to.execute=<{0}> 以执行
1.lines.covered=覆盖的行 <1%
abbreviated.month.name.always.3.letters.jul=(Jul) 月份名称缩写。始终为 3 个字母
abbreviated.weekday.name.always.3.letters.sun=(Sun) 星期名称缩写。始终为 3 个字母
action.Cargo.AttachCargoProject.text=附加 Cargo 项目
action.Cargo.DetachCargoProject.text=分离 Cargo 项目
action.Cargo.RefreshCargoProject.description=更新 Cargo 项目信息并下载新的依赖项
action.Cargo.RefreshCargoProject.text=刷新 Cargo 项目
action.Cargo.RunCargoCommand.text=运行 Cargo 命令
action.Cargo.RunExternalLinter.text=运行外部 Linter
action.Cargo.RustfmtCargoProject.description=使用 Rustfmt 重新设置 Cargo 项目的格式
action.Cargo.RustfmtCargoProject.text=使用 Rustfmt 重新设置 Cargo 项目的格式
action.Cargo.RustfmtFile.default.text=使用 Rustfmt 重新设置文件格式
action.Cargo.RustfmtFile.description=使用 Rustfmt 重新设置当前文件的格式
action.Cargo.RustfmtFile.file.text=使用 Rustfmt 重新设置{0}的格式
action.Cargo.RustfmtFile.progress.default.text=正在使用 Rustfmt 重新设置文件格式…
action.Cargo.RustfmtFile.progress.file.text=正在使用 Rustfmt 重新设置{0}的格式…
action.Cargo.RustfmtFile.text=Reformat File with Rustfmt
action.Cargo.ShowSettings.description=编辑当前项目的 Cargo 设置
action.Cargo.ShowSettings.text=Cargo 设置
action.Cargo.ToggleExternalLinterOnTheFlyAction.text=即时运行外部 Linter (Cargo Check/Clippy)
action.Rust.Build.description=构建项目
action.Rust.Build.text=构建
action.Rust.ConsoleREPL.text=Rust REPL
action.Rust.CreateNewGithubIssue.description=在 https\://github.com/intellij-rust/intellij-rust 仓库中创建新问题
action.Rust.CreateNewGithubIssue.text=创建新问题
action.Rust.GenerateConstructor.text=构造函数
action.Rust.GenerateDictionaries.text=生成 Rust 拼写检查器字典
action.Rust.GenerateGetter.text=Getter
action.Rust.GenerateSetter.text=Setter
action.Rust.NewCargoCrate.description=创建新的 Cargo crate
action.Rust.NewCargoCrate.text=Cargo Crate
action.Rust.NewRustFile.description=创建一个新的 Rust 文件
action.Rust.NewRustFile.text=Rust 文件
action.Rust.RebuildAllDefMaps.text=Rust\: 为所有 crate 重建 DefMap
action.Rust.RebuildCurrentDefMap.text=Rust\: 为当前文件重建 DefMap
action.Rust.ReexpandMacrosAction.text=重新展开所有 Rust 宏
action.Rust.RsConvertToNamedFields.description=将元组结构转换为命名字段
action.Rust.RsConvertToNamedFields.text=转换为命名字段
action.Rust.RsConvertToTuple.description=将结构转换为元组表示
action.Rust.RsConvertToTuple.text=转换为元组
action.Rust.RsDowngradeModuleToFile.description=将此模块移至单独的文件
action.Rust.RsDowngradeModuleToFile.text=将模块降级为文件
action.Rust.RsExtractEnumVariant.description=将单个枚举变体提取到单独的结构中
action.Rust.RsExtractEnumVariant.text=提取枚举变体
action.Rust.RsExtractStructFields.choose.fields.title=选择要提取的字段
action.Rust.RsExtractStructFields.choose.name.dialog.invalid.name=结构名称无效
action.Rust.RsExtractStructFields.choose.name.dialog.title=输入新结构的名称
action.Rust.RsExtractStructFields.command.name=正在提取结构字段
action.Rust.RsExtractStructFields.description=将所选结构字段提取到单独的结构中
action.Rust.RsExtractStructFields.intention.text=提取结构字段
action.Rust.RsExtractStructFields.text=提取结构字段…
action.Rust.RsExtractTrait.description=从所选 impl 提取特征
action.Rust.RsExtractTrait.dialog.title=提取特征
action.Rust.RsExtractTrait.text=提取特征…
action.Rust.RsPromoteModuleToDirectoryAction.description=将此模块移至专用目录
action.Rust.RsPromoteModuleToDirectoryAction.text=将模块提升到目录
action.Rust.ShareInPlayground.confirmation=是否要将 {0} 上传到 Rust Playground 并使之公开?
action.Rust.ShareInPlayground.confirmation.selected.text=是否要将所选文本上传到 Rust Playground 并使之公开?
action.Rust.ShareInPlayground.description=在 Rust Playground (https\://play.rust-lang.org/)中共享代码
action.Rust.ShareInPlayground.notification.copy.url.text=将 URL 复制到剪贴板
action.Rust.ShareInPlayground.notification.error=无法将代码共享到 Rust Playground
action.Rust.ShareInPlayground.notification.text=Rust Playground 中共享的文件\: <a href\="{0}">{0}</a>
action.Rust.ShareInPlayground.notification.title=在 Rust Playground 中共享
action.Rust.ShareInPlayground.progress.title=正在将代码发布到 Rust Playground
action.Rust.ShareInPlayground.text=在 Playground 中共享
action.Rust.ShowRecursiveMacroExpansionAction.text=显示递归展开的宏
action.Rust.ShowSingleStepMacroExpansionAction.text=显示展开的宏
action.Rust.ToggleNewResolve.text=Rust\: 切换新的名称解析引擎
action.all.features.description={0}所有功能
action.all.features.text={0}所有功能
action.enable.text=开启
action.enter.type.name.text=输入类型名称…
action.expr.text=(expr)
action.for.text=用于 { }
action.if.expr.text=if expr
action.if.text=if { }
action.install.text=安装
action.loop.text=loop { }
action.rerun.text=重新运行 ''{0}''
action.run.on.fly.text=即时运行 {0}
action.rust.coverage.text=Rust 覆盖率
action.show.settings.text=显示设置…
action.show.variables.text=显示变量
action.shows.active.console.variables.description=显示有效控制台变量
action.stop.console.text=停止控制台
action.stop.rust.console.description=停止 Rust 控制台
action.while.expr.text=while expr
action.while.text=while { }
adt.const.params=adt const params
advanced.setting.org.rust.cargo.test.tool.window=在“测试”工具窗口中显示测试结果
advanced.setting.org.rust.cargo.test.tool.window.description=显示结构化测试结果。由于可能存在不一致，不建议在使用 Rust 1.70.0+ 稳定工具链时使用。
advanced.setting.org.rust.convert.json.to.struct=在粘贴时启用 JSON 到 Rust 的转换
advanced.setting.org.rust.external.doc.url=外部文档的基 URL
advanced.setting.org.rust.macros.maximum.recursion.limit=宏展开的最大递归限制
advanced.setting.org.rust.macros.maximum.recursion.limit.description=仅当您遇到性能问题时才更改它
advanced.setting.rust.group=Rust
am.or.pm.in.12.hour.clocks=12 小时制的上午或下午
am.or.pm.in.12.hour.clocks2=12 小时制的上午或下午
and.impls=和 impl
associated.type.defaults=关联类型默认值
backtrace=反向跟踪(&T)\:
border.title.inline=内联{0}
border.title.inline.type.alias=内联类型别名
border.title.project.template=项目模板
box.expression.syntax=`box` 表达式语法
box.pattern.syntax=`box` 模式语法
build=构建
build.event.message.={0} {1}
build.event.message.build.scripts.evaluation.failed.features.based.on.generated.info.by.build.scripts.may.not.work.in.your.ide=构建脚本评估失败。基于由构建脚本生成信息的功能可能无法在您的 IDE 中运行
build.event.message.cargo.project.update.failed.no.rust.toolchain=Cargo 项目更新失败\: 没有 Rust 工具链
build.event.message.compiling=正在编译
build.event.message.compiling.0=正在编译{0}
build.event.message.fetching.cargo.config.failed=提取 Cargo 配置失败。\n\n{0}
build.event.message.fetching.target.specific.cfg.options.failed.fallback.to.host.options=提取目标特定的 `cfg` 选项失败。回退到主机选项。\n\n{0}
build.event.message.fresh=Fresh
build.event.message.internal.compiler.error=内部编译器错误\:
build.event.message.project.directory.does.not.exist.consider.detaching.project.from.cargo.tool.window=项目目录 `{0}` 不存在。\n请考虑从 Cargo 工具窗口中分离项目 `{1}`。
build.event.message.running={0}正在运行…
build.event.title.build.scripts.evaluation=构建脚本评估
build.event.title.build.scripts.evaluation.failed=构建脚本评估失败
build.event.title.cargo=Cargo
build.event.title.failed.to.fetch.rustc.version=无法提取 rustc 版本
build.event.title.failed.to.fetch.stdlib.package.info=无法提取 stdlib 软件包信息
build.event.title.failed.to.load.stdlib.dependencies=无法加载 stdlib 依赖项
build.event.title.fetching.cargo.config=正在提取 Cargo 配置
build.event.title.fetching.target.specific.cfg.options=正在提取针对特定目标的 `cfg` 选项
build.event.title.run.cargo.command=运行 Cargo 命令
build.event.title.sync.project=同步 {0} 项目
c.str.literals=`c".."` 文字
cargo=Cargo
cargo.command.run.configuration=Cargo 命令运行配置
cargo.commandline.description=在给定文件夹下配置 Cargo 项目
cargo.commands=Cargo 命令
cargo.test=cargo 测试
cargo.toml=Cargo.toml
cargo.toml.schema=Cargo.toml 架构
checkbox.async=异步
checkbox.build.on.remote.target=在远程目标上构建
checkbox.convert.all.usages=转换所有用法
checkbox.emulate.terminal.in.output.console=在输出控制台中模拟终端
checkbox.enable.inspection.only.if.procedural.macros.are.enabled=仅当过程宏启用时才启用检查
checkbox.ignore.unresolved.references.with.possibly.high.false.positive.rate=忽略误报率可能较高的未解析的引用
checkbox.ignore.unused.imports.in.doctests=忽略 doctest 中未使用的 import
checkbox.implicitly.add.required.features.if.possible=尽可能隐式添加必选功能
checkbox.run.with.administrator.privileges=以管理员权限运行
checkbox.run.with.root.privileges=以 root 权限运行
checkbox.unsafe=非安全
checkbox.use.all.features.in.tests=在测试中使用所有功能
code.vision.disable.hints.message=\n             要禁用函数的提示，请使用适当的模式\:<br />\n            <b>std\:\:*</b> - 标准库中的函数<br />\n            <b>std\:\:fs\:\:*(*, *)</b> - <i>std\:\:fs</i> 模块中接受两个形参的函数<br />\n            <b>(*_)</b> - 形参名称以 <i>_</i> 结尾的单形参函数<br />\n            <b>(key, value)</b> - 包含 <i>key</i> 和 <i>value</i> 形参的函数<br />\n            <b>*.put(key, value)</b> - 包含 <i>key</i> 和 <i>value</i> 形参的 <i>put</i> 函数\n
column.name.apply.to=应用于
column.name.covered=已覆盖，%
column.name.file=文件
column.name.item.or.module=条目或模块
column.name.mutable=可变
column.name.pattern=模式\:
column.name.scope=范围
command=命令(&C)\:
command.name.choose.constant.name=选择一个常量名称
command.name.choose.field.name=选择字段名称
command.name.choose.parameter=选择 形参
command.name.choose.struct.name=选择结构名称
command.name.choose.variable=选择一个变量
command.name.converting.to.named.fields=正在将 {0} 转换为命名字段
command.name.converting.to.tuple=正在将 {0} 转换为元组
command.name.extract.trait=提取特征
command.name.extracting.variant=正在提取变体 {0}
command.name.inline=内联{0} {1}
command.name.inline.function=内联函数 {0}
command.name.inline.type.alias=内联类型别名 {0}
command.name.introduce.local.variable=引入局部变量
command.name.move.items=移动条目
command.name.postfix.let.template=后缀 `let` 模板
command2=命令\:
configurable.name.rust.external.linter=Rust 外部 Linter
configure=配置...
console.is.not.enabled=控制台未启用。
const.closures=const 闭包
const.fn.trait.bound=const fn 特征边界
const.generics.defaults=const 泛型默认值
const.trait.impls=const 特征 impl
constants.equal.to.1=常量等于 1
copy.paste.convert.json.to.struct.dialog.text=插入的文本似乎是 JSON 对象。是否要从它生成 Rust 结构?
copy.paste.convert.json.to.struct.dialog.title=从 JSON 生成 Rust 结构
corrupted.standard.library.0=已损坏的标准库\: {0}
crate.in.paths=路径中的 `crate`
dangling.else=悬空的 else
day.month.year.format.same.as.e.b.y=(8-Jul-2001)日-月-年格式。与 %e-%b-%Y 相同
day.number.01.31.zero.padded.to.2.digits=日数字(01?31)，在前面填充零，变成 2 位数
day.of.the.year.001.366.zero.padded.to.3.digits=(189)一年中的第几天，在前面填充零，变成 3 位数
dbg.usage=\#[dbg] 用法
deprecated.item=已弃用的条目
details=详细信息\:
dialog.create.project.custom.add.template.action.add=添加
dialog.create.project.custom.add.template.name=名称\:
dialog.create.project.custom.add.template.title=添加自定义模板
dialog.create.project.custom.add.template.url=模板 URL\:
dialog.create.project.custom.add.template.url.description=支持 cargo-generate 的模板。<a href\="https\://github.com/cargo-generate/cargo-generate/blob/master/TEMPLATES.md">可用模板</a>
dialog.message.can.not.generate.coverage.report=无法生成覆盖率报告\: {0}
dialog.message.can.t.create.new.rust.file.or.attach.it.to.module.tree=无法创建新的 Rust 文件或将其附加到模块树
dialog.message.can.t.detect.target.process.id=无法检测目标进程 ID
dialog.message.can.t.find.binary=找不到二进制文件
dialog.message.can.t.get.output.perf.data.file=无法获取输出 perf 数据文件
dialog.message.cannot.change.signature.function.in.foreign.crate=无法更改外部 crate 中函数的签名
dialog.message.cannot.inline.constant.without.expression=无法在没有表达式的情况下内联常量
dialog.message.cannot.inline.empty.function=无法内联空函数
dialog.message.cannot.inline.function.with.more.than.one.exit.points=无法内联具有多个出口点的函数
dialog.message.cannot.inline.function.with.recursive.calls=无法通过递归调用内联函数
dialog.message.cannot.inline.multiline.function.into.while.loop.condition=无法将多行函数内联到 "while" 循环条件中
dialog.message.cannot.inline.variable.without.expression=无法在没有表达式的情况下内联变量
dialog.message.cannot.inline.variable.without.identifier=无法内联没有标识符的变量
dialog.message.caret.should.be.positioned.at.function.or.method=文本光标应放置在函数或方法处
dialog.message.cargo.generate.needed.to.create.project.from.custom.template=需要使用 cargo-generate 从自定义模板创建项目
dialog.message.channel.cannot.be.set.explicitly.because.rustup.not.available=无法显式设置通道，因为 rustup 不可用
dialog.message.channel.set.explicitly.with.no.rustup.available=通道 ''{0}'' 已显式设置，但没有可用的 rustup
dialog.message.debug.toolchain.not.configured=未配置调试工具链。
dialog.message.default.value.entered.for.parameter.invalid=为形参 {0} 输入的默认值无效
dialog.message.directory.already.exists=目录 {0} 已存在.
dialog.message.do.you.want.to.find.usages.base.declaration=是否要查找基声明的用法?
dialog.message.enter.custom.type.name.type.parameters.are.not.supported=输入自定义类型名称。不支持类型形参。
dialog.message.error.during.creating.new.rust.file=创建新 Rust 文件的过程中出错\: {0}
dialog.message.failed.to.prepare.remote.environment=无法准备远程环境\: {0}
dialog.message.file.not.found=找不到文件\: {0}
dialog.message.file.will.not.be.included.in.module.tree.after.move.continue=移动后文件将不会包含在模块树中。是否继续?
dialog.message.function.name.must.be.valid.rust.identifier=函数名称必须是有效的 Rust 标识符
dialog.message.function.return.type.must.be.valid.rust.type=函数的返回值类型必须是有效的 Rust 类型
dialog.message.function.visibility.must.be.valid.visibility.specifier=函数可见性必须是有效的可见性说明符
dialog.message.gnu.debugger.cannot.be.used.with.msvc.rust.toolchain=GNU 调试器不能与 MSVC Rust 工具链一起使用。
dialog.message.gnu.toolchain.not.supported.please.use.msvc.toolchain=不支持 GNU 工具链。请使用 MSVC 工具链。
dialog.message.html.body.br.b.b.body.html=<html><body>{0}{1}<br/><b>{2}</b> {3}</body></html>\n
dialog.message.html.coverage.report.has.been.successfully.saved.as.file.br.use.instruction.in.href.to.generate.html.output.html=<html>覆盖率报告已成功保存为 ''{0}'' 文件。<br>使用 <a href\=''{1}''>{2}</a> 中的说明生成 HTML 输出。</html>
dialog.message.html.local.debugger.cannot.be.used.with.wsl.br.use.href.https.www.jetbrains.com.help.clion.how.to.use.wsl.development.environment.in.product.html.instructions.to.configure.wsl.toolchain.html=<html>本地调试器不能与 WSL 一起使用。<br>请使用<a href\='https\://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html'>说明</a>来配置 WSL 工具链。</html>
dialog.message.illegal.path=非法路径\: {0}
dialog.message.input.file.doesn.t.exist=输入文件不存在
dialog.message.input.file.not.valid=输入文件无效
dialog.message.internal.error.can.t.find.process.starter=内部错误\: 找不到进程启动器
dialog.message.invalid.identifier=无效标识符
dialog.message.invalid.toolchain=无效的工具链\: {0}
dialog.message.more.than.one.binary.was.produced.please.specify.bin.lib.test.or.example.flag.explicitly=产生了多个二进制文件。请显式指定 `--bin`、`--lib`、`--test` 或 `--example` 标志。
dialog.message.msvc.debugger.cannot.be.used.with.gnu.rust.toolchain=MSVC 调试器不能与 GNU Rust 工具链一起使用。
dialog.message.msvc.toolchain.not.supported.please.use.gnu.toolchain=不支持 MSVC 工具链。请使用 GNU 工具链。
dialog.message.name.cannot.be.used.as.crate.name=名称 `{0}` 不能用作 crate 名称
dialog.message.name.cannot.be.used.as.crate.name2=名称 `{0}` 不能用作 crate 名称
dialog.message.name.reserved.windows.filename=名称 `{0}` 是保留的 Windows 文件名
dialog.message.no.command.specified=未指定命令
dialog.message.no.rust.toolchain.specified=未指定 Rust 工具链
dialog.message.no.suitable.function.to.extract.parameter.found=找不到合适的函数来提取形参。
dialog.message.no.working.directory.specified=未指定工作目录
dialog.message.package.name.can.t.be.empty=软件包名称不能为空
dialog.message.package.names.should.contain.only.letters.digits=软件包名称只能包含字母、数字、`-` 和 `_`
dialog.message.package.names.starting.with.digit.cannot.be.used.as.crate.name=以数字开头的软件包名称不能用作 crate 名称
dialog.message.parameter.has.invalid.pattern=形参 {0} 具有无效模式
dialog.message.perf.profiler.not.available.for.selected.toolchain=Perf 分析器对所选工具链不可用
dialog.message.perf.profiler.not.available.for.selected.wsl.distribution.try.updating.wsl.to.newer.one=Perf 分析器对所选 WSL 分发版不可用\n尝试将 WSL 更新到较新的版本
dialog.message.please.choose.target.directory.different.from.current=请选择与当前目录不同的目标目录
dialog.message.please.enter.type.for.parameter=请输入形参 {0} 的类型
dialog.message.profiler.connection.error.can.t.detect.target.process.id=分析器连接错误\: 无法检测到目标进程 id
dialog.message.run.targets.cannot.be.used.alongside.with.wsl.toolchain=运行目标不能与 WSL 工具链一起使用
dialog.message.target.file.must.be.rust.file=目标文件必须是 Rust 文件
dialog.message.this.cargo.package.already.part.attached.workspace=此 Cargo 软件包已是附加工作区的一部分。
dialog.message.type.entered.for.parameter.invalid=为形参 {0} 输入的类型无效
dialog.message.wsl.debugger.cannot.be.used.with.non.wsl.rust.toolchain=WSL 调试器不能与非 WSL Rust 工具链一起使用。
dialog.message.wsl.toolchain.not.supported=不支持 WSL 工具链。
dialog.title.choose.destination.file=选择目标文件
dialog.title.convert.to.named.fields.settings=转换为命名字段设置
dialog.title.convert.to.tuple=转换为元组
dialog.title.coverage.report.generation=覆盖率报告生成
dialog.title.download.debugger=下载调试器
dialog.title.enter.type.name=输入类型名称
dialog.title.extract.function=提取函数
dialog.title.find.usages=查找用法
dialog.title.implement.members=实现成员
dialog.title.installing.cargo.generate=正在安装 cargo-generate
dialog.title.move=移动
dialog.title.move.module.items=移动模块条目
dialog.title.move.rust=移动(Rust)
dialog.title.new.cargo.crate=新建 Cargo Crate
dialog.title.select.cargo.toml=选择 Cargo.toml
dialog.title.select.module=选择模块
dialog.title.unable.to.attach.cargo.project=无法附加 Cargo 项目
dialog.title.unable.to.build=无法构建
dialog.title.unable.to.run.debugger=无法运行调试器
dialog.title.unable.to.run.profiler=无法运行分析器
dialog.title.unable.to.run.valgrind=无法运行 Valgrind
disable=禁用
disabling.the.test.tool.window=禁用“测试”工具窗口
discriminant.on.a.non.unit.variant=判别式位于非单元变体上
don.t.show.again=不再显示
double.negation=双重求反
download.failed.0=下载失败\: {0}
drop.reference=丢弃引用
duplicated.trait.method.parameter.binding=重复的特征方法形参绑定
empty.0=空 {0}
enum=enum
error.message.struct.inheritance.is.not.supported=Rust 不支持结构继承
exclusive.range.patterns=独占范围模式
expected.0.found.1=应为 `{0}`，实际为 `{1}`
extern.crate.self=`extern crate self`
extern.types=extern 类型
external.linter=外部 Linter
extra.semicolon=额外的分号
failed.to.get.project.sysroot=无法获取项目 sysroot
failed.to.run.cargo=无法运行 Cargo
fetching.actual.stdlib.info.failed.hardcoded.stdlib.structure.will.be.used=提取实际 stdlib 信息失败。将使用硬编码的 stdlib 结构
file=文件
fn.0=fn {0}
from=从\:
full.month.name.july=(July)月份的完整名称
full.weekday.name.sunday=(Sunday)星期的完整名称
generic.associated.types=泛型关联类型
go.to.class.kind.text=类型
go.to.class.kind.text.pluralized=类型
group.Rust.MacroExpansionActions.text=显示宏展开
group.Rust.Tools.text=Rust
gutter.rust.generated.typescript.declarations.name=生成的 TypeScript 声明
gutter.rust.generated.typescript.declarations.popup.title=生成的声明
gutter.rust.generated.typescript.declarations.tooltip=转到生成的声明
gutter.rust.implemented.item.name=Implemented item
gutter.rust.implemented.item.tooltip=具有实现
gutter.rust.implementing.item=实现条目
gutter.rust.open.documentation.for=打开 `{0}` 的文档
gutter.rust.open.documentation.name=打开文档
gutter.rust.open.documentation.toml.name=打开文档(TOML)
gutter.rust.overriding.item=重写条目
gutter.rust.recursive.call.name=递归调用
half.open.range.patterns=半开范围模式
hint.text.html.table.tr.td.style.color.type.td.td.style.font.family.monospace.td.tr.tr.td.style.color.coerced.type.td.td.style.font.family.monospace.td.tr.table.html=\n                <html>\n                    <table>\n                        <tr>\n                            <td style\="color\: \#909090">类型\:</td>\n                            <td style\="font-family\: monospace;">{0}</td>\n                        </tr>\n                        <tr>\n                            <td style\="color\: \#909090">强制类型\:</td>\n                            <td style\="font-family\: monospace;">{1}</td>\n                        </tr>\n                    </table>\n                </html>\n
hint.text.no.members.to.implement.have.been.found=找不到要实现的成员
hint.text.please.convert.innermost.impl.trait.first=请先转换最里面的 `impl Trait`
hint.text.select.expression=选择表达式\!
hint.text.some.elements.that.action.going.to.change.exist.only.in.macro.expansion.so.cannot.be.changed.by.action=该操作要更改的某些元素仅存在于宏展开中，因此不能由该操作更改
hour.minute.format.same.as.h.m=(00\:34)小时-分钟格式。与 %H\:%M 相同
hour.minute.second.format.in.12.hour.clocks.same.as.i.m.s.p=(12\:34\:60 AM)12 小时制的小时-分钟-秒格式。与 %I\:%M\:%S %p 相同
hour.minute.second.format.same.as.h.m.s=(00\:34\:60)小时-分钟-秒格式。与 %H\:%M\:%S 相同
hour.number.00.23.zero.padded.to.2.digits=(00-23)小时数字，在前面填充零，变成 2 位数
hour.number.in.12.hour.clocks.01.12.zero.padded.to.2.digits=(01-12) 12 小时制小时数字，在前面填充零，变成 2 位数
html.head.0.style.body.background.1.text.align.center.style.head.body.2.body.html=\n        <html>\n        <head>\n            {0}\n            <style>body '{'background\: \#{1}; text-align\: center; '}'</style>\n        </head>\n        <body>\n            {2}\n        </body>\n        </html>\n
if.let.guard=if let guard
inherent.associated.types=固有关联类型
inline.const=inline const
inline.const.pat=inline const pat
inspection.DoubleMustUse.FixRemoveMustUseAttr.name=从函数中移除 `\#[must_use]`
inspection.DoubleMustUse.description=此函数具有 `\#[must_use]` 特性，但返回已标记为 `\#[must_use]` 的类型
inspection.PathStatementsInspection.description.drops.value=路径语句丢弃值
inspection.PathStatementsInspection.description.no.effect=路径语句不起任何作用
inspection.RedundantSemicolons.description.multiple=不必要的尾随分号
inspection.RedundantSemicolons.description.single=不必要的尾随分号
inspection.RedundantSemicolons.fix.name=移除不必要的尾随分号
inspection.UnusedLabels.description=未使用的标签
inspection.UnusedMustUse.AddAwaitFix.name=添加 `.await`
inspection.UnusedMustUse.FixAddExpect.family.name=添加 `.expect("")`
inspection.UnusedMustUse.FixAddLetUnderscore.name=添加 `let _ \=`
inspection.UnusedMustUse.FixAddUnwrap.name=添加 `.unwrap()`
inspection.UnusedMustUse.description.function.attribute=必须使用但未使用的 {0} 返回值
inspection.UnusedMustUse.description.type.attribute=必须使用但未使用的{0}
inspection.cargo.toml.cyclic.feature.display.name=循环功能依赖关系
inspection.crate.not.found.display.name=找不到 crate
inspection.crate.version.invalid.display.name=crate 版本无效
inspection.duplicated.key.display.name=重复键
inspection.message.={0} [{1}]
inspection.message.access.nonexistent.field=类型 `{1}` 上没有字段 `{0}`
inspection.message.access.to.union.field.unsafe.requires.unsafe.function.or.block=对联合字段的访问不安全，需要非安全函数或块
inspection.message.align.argument.must.be.power.two=`align` 实参必须是 2 的幂
inspection.message.align.argument.must.be.unsuffixed.integer=`align` 实参必须是无后缀整数
inspection.message.align.argument.must.not.be.larger.than=`align` 实参不得大于 2^29
inspection.message.align.needs.argument=`align` 需要一个实参
inspection.message.align.takes.exactly.one.argument.in.parentheses=`align` 只接受圆括号中的一个实参
inspection.message.all.versions.matching.for.crate.are.yanked=与 crate {1} 的 {0} 匹配的所有版本均被移除
inspection.message.anonymous.functions.parameters.are.deprecated.rfc=匿名函数形参已弃用(RFC 1685)
inspection.message.approximate.value.found.consider.using.it.directly=找到了 `{0}` 的近似值。考虑直接使用它。
inspection.message.are.not.allowed.inside={1} {2} 内不允许使用 {0}
inspection.message.argument.never.used=实参从未使用
inspection.message.array.size.cannot.refer.to.static=数组大小不能引用 static `{0}`
inspection.message.assert.b.can.be.b=assert\!(a {0} b) 可以是 {1}\!(a, b)
inspection.message.associated.type.not.found.for=找不到 `{1}` 的关联类型 `{0}`
inspection.message.async.non.move.closures.with.parameters.are.currently.not.supported=目前不支持带形参的异步非 move 闭包
inspection.message.at.least.one.trait.required.for.object.type=对象类型至少需要一个特征
inspection.message.attribute.should.be.applied.to.enum={0} 特性应该应用于枚举
inspection.message.attribute.should.be.applied.to.function.or.closure=特性应该应用于函数或闭包
inspection.message.attribute.should.be.applied.to.struct.enum.or.union={0} 特性应该应用于结构、枚举或联合
inspection.message.attribute.should.be.applied.to.struct.or.union={0} 特性应该应用于结构或联合
inspection.message.attributes.on.function.parameters.experimental=函数形参的特性是实验性的
inspection.message.await.only.allowed.inside.async.functions.blocks=只允许在 `async` 函数和块内使用 `await`
inspection.message.binding.never.used=绑定 `{0}` 从未使用
inspection.message.boolean.expression.can.be.simplified=布尔表达式可以简化
inspection.message.bounds.on.have.no.effect={0} 上的边界不起任何作用
inspection.message.bounds.on.have.no.effect2={0} 上的边界不起任何作用
inspection.message.bounds.on.have.no.effect3={0} 上的边界不起任何作用
inspection.message.break.with.value.from.loop=带有来自 `{0}` 循环的值的 `break`
inspection.message.c.variadic.function.must.have.compatible.calling.convention.like.c.or.cdecl=C 可变函数必须具有兼容的调用约定，例如 `C` 或 `cdecl`
inspection.message.call.to.std.mem.drop.with.reference.argument.dropping.reference.does.nothing=使用引用实参调用 std\:\:mem\:\:drop。删除引用不会执行任何操作
inspection.message.call.to.unsafe.function=对非安全函数的调用
inspection.message.call.to.unsafe.function.requires.unsafe.function.or.block=对非安全函数的调用需要非安全函数或块
inspection.message.calls.in.constants.are.limited.to.constant.functions.tuple.structs.tuple.variants=常量中的调用仅限于常量函数、元组结构和元组变体
inspection.message.can.be.replaced.with.literal.suffix=可被替换为文字后缀
inspection.message.can.be.replaced.with.random=可被替换为 ''random{0}()''
inspection.message.can.impl.only.struct.s.enum.s.union.s.trait.objects=只能 impl `struct`、`enum`、`union` 和特征对象
inspection.message.can.t.capture.dynamic.environment.in.fn.item=无法捕获 fn 条目中的动态环境
inspection.message.can.t.find.crate.for=找不到 `{0}` 的 crate
inspection.message.cannot.assign.to=无法分配给 {0}
inspection.message.cannot.assign.twice.to.immutable.variable=无法为不可变变量赋值两次
inspection.message.cannot.be.declared.unsafe=不能将 {0} 声明为 unsafe
inspection.message.cannot.be.used.in.closures.only.inside.loop.while.blocks=`{0}` 不能在闭包中使用，只能在 `loop` 和 `while` 块中使用
inspection.message.cannot.be.variadic={0} 不能是可变的
inspection.message.cannot.be.variadic2={0} 不能是可变的
inspection.message.cannot.borrow.immutable.local.variable.as.mutable=无法借用不可变局部变量 `{0}` 作为可变变量
inspection.message.cannot.declare.non.inline.module.inside.block.unless.it.has.path.attribute=不能在块内声明非内联模块，除非它具有路径特性
inspection.message.cannot.define.inherent.impl.for.dyn.auto.trait=无法为 dyn auto trait 定义固有 `impl`
inspection.message.cannot.define.inherent.impl.for.type.outside.crate.where.type.defined=无法为定义类型的 crate 之外的类型定义固有 `impl`
inspection.message.cannot.have.anonymous.parameters={0} 不能有匿名形参
inspection.message.cannot.have.anonymous.parameters2={0} 不能有匿名形参
inspection.message.cannot.have.body={0} 不能有主体
inspection.message.cannot.have.body2={0} 不能有主体
inspection.message.cannot.have.const.qualifier={0} 不能有 `const` 限定符
inspection.message.cannot.have.default.qualifier={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier10={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier11={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier2={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier3={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier4={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier5={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier6={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier7={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier8={0} 不能有 `default` 限定符
inspection.message.cannot.have.default.qualifier9={0} 不能有 `default` 限定符
inspection.message.cannot.have.extern.abi={0} 不能有 extern ABI
inspection.message.cannot.have.generic.parameters={0} 不能有泛型形参
inspection.message.cannot.have.pub.qualifier={0} 不能有 `pub` 限定符
inspection.message.cannot.have.pub.qualifier2={0} 不能有 `pub` 限定符
inspection.message.cannot.have.self.parameter={0} 不能有 `self` 形参
inspection.message.cannot.have.self.parameter2={0} 不能有 `self` 形参
inspection.message.cannot.have.unsafe.qualifier={0} 不能有 `unsafe` 限定符
inspection.message.cannot.have.where.clause={0} 不能有 `where` 子句
inspection.message.cannot.have.where.clause.after.type={0} 在类型后面不能有 `where` 子句
inspection.message.cannot.have.where.clause.before.type={0} 在类型前面不能有 `where` 子句
inspection.message.cannot.implement.both.copy.drop=无法同时实现 Copy 和 Drop
inspection.message.cannot.move=无法移动
inspection.message.chained.comparison.operator.require.parentheses=链式比较运算符需要圆括号
inspection.message.condition.always=条件始终为 ''''{0}''''
inspection.message.const=const
inspection.message.const.cannot.refer.to.static=const `{0}` 不能引用 static `{1}`
inspection.message.const.generic.argument.cannot.refer.to.static=const 泛型实参不能引用 static `{0}`
inspection.message.const2=const
inspection.message.constant=常量 `{0}`
inspection.message.constant.function.cannot.refer.to.static=常量函数 `{0}` 不能引用 static `{1}`
inspection.message.consts={0}\:\:{1}\:\:consts\:\:{2}
inspection.message.continue.pointing.to.labeled.block=指向带标签块的 `Continue`
inspection.message.crate.in.paths.can.only.be.used.in.start.position=路径中的 `crate` 只能在起始位置使用
inspection.message.crate.not.found=找不到 crate {0}
inspection.message.cyclic.feature.dependency.feature.depends.on.itself=循环功能依赖关系\: 功能 `{0}` 依赖于自身
inspection.message.default.cannot.have.pub.qualifier=默认 {0} 不能有 `pub` 限定符
inspection.message.default.parameter.values.are.not.supported.in.rust=Rust 不支持默认形参值
inspection.message.defaults.for.const.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=const 形参的默认值只允许在 `struct、`enum`、`type` 或 `trait` 定义中使用
inspection.message.defaults.for.type.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=类型形参的默认值只允许在 `struct、`enum`、`type` 或 `trait` 定义中使用
inspection.message.denote.infinite.loops.with.loop=使用 `loop { ... }` 表示无限循环
inspection.message.dereference.raw.pointer.requires.unsafe.function.or.block=取消引用原始指针需要非安全函数或块
inspection.message.derive.may.only.be.applied.to.structs.enums.unions=`derive` 只能应用于结构、枚举和联合
inspection.message.different.impl.member.order.from.trait=与特征不同的 impl 成员顺序
inspection.message.discriminant.value.already.exists=判别值 `{0}` 已存在
inspection.message.doesn.t.derive.both.partialeq.eq={0} 不会同时派生 `PartialEq` 和 `Eq`
inspection.message.doesn.t.implement.required.by=`{0}` 不会实现 `{1}` (`{2}` 需要)
inspection.message.drop.can.be.only.implemented.by.structs.enums=drop 只能由结构和枚举实现
inspection.message.duplicate.definitions.with.name=名称为 `{0}` 的重复定义
inspection.message.duplicate.field=重复字段
inspection.message.duplicated.parameter.name.consider.renaming.it=重复的形参名称 `{0}`。考虑对其重命名
inspection.message.enum.variant=枚举变体
inspection.message.enum.variant.s.discriminant.value.cannot.refer.to.static=枚举变体 `{0}` 的判别值不能引用 static `{1}`
inspection.message.enum.with.no.variants.can.t.have.repr.attribute=没有变体的枚举不能有 `repr` 特性
inspection.message.expected.cfg.pattern=应为 1 个 cfg 模式
inspection.message.expected.function.found=应为函数，实际为 `{0}`
inspection.message.expected.path.to.trait.found.literal=应为特征的路径，实际为文字
inspection.message.expected.trait.bound.found.impl.trait.type=应为特征边界，实际为 `impl Trait` 类型
inspection.message.expected.trait.found=应为特征，但实际为{0} `{1}`
inspection.message.experimental={0} 是实验性的
inspection.message.explicit.calls.to.drop.are.forbidden.use.std.mem.drop.instead=禁止显式调用 `drop`。请改用 `std\:\:mem\:\:drop`
inspection.message.explicit.impls.for.sized.trait.are.not.permitted=不允许为 `Sized` 特征使用显式 impl
inspection.message.explicit.impls.for.unsize.trait.are.not.permitted=不允许为 `Unsize` 特征使用显式 impl
inspection.message.explicit.lifetimes.given.in.parameter.types.where.they.could.be.elided=形参类型中给出的显式生命周期可以省略
inspection.message.expression.can.be.simplified=表达式可以简化
inspection.message.expressions.must.be.enclosed.in.braces.to.be.used.as.const.generic.arguments=表达式必须用大括号括起来才能用作 const 泛型实参
inspection.message.extern=extern
inspection.message.extern.crate.self.requires.as.name=`extern crate self` 需要 `as name`
inspection.message.extra.field.found.in.pattern=在{0}模式中找到了额外字段\: `{1}`
inspection.message.extra.fields.found.in.tuple.struct.pattern.expected.found=在元组结构模式中找到了额外字段\: 应为 {0} 个，但实际为 {1} 个
inspection.message.feature.has.been.removed=功能 `{0}` 已被移除
inspection.message.feature.may.not.be.used.on.release.channel=`\#\![feature]` 无法在{0}发布通道上使用
inspection.message.field.already.declared=字段 `{0}` 已声明
inspection.message.field.bound.multiple.times.in.pattern=字段 `{0}` 在模式中被多次绑定
inspection.message.field.struct.private=结构 `{1}` 的字段 `{0}` 为 private
inspection.message.file.not.found.for.module=找不到模块 `{0}` 的文件
inspection.message.file.not.included.in.module.tree.analysis.not.available=文件不包含在模块树中，无法进行分析
inspection.message.for.loop.expression.has.unnecessary.parentheses=for 循环表达式有不必要的圆括号
inspection.message.foreign.items.may.not.have.parameters=外部条目不能有 {0} 形参
inspection.message.from.trait=`{0}` (来自特征 `{1}`)
inspection.message.function.returns.instead=函数返回 () 而不是 {0}
inspection.message.functions.with.start.attribute.must.have=具有 `start` 特性的函数必须具有{0}
inspection.message.functions.with.start.attribute.must.return.isize=具有 `start` 特性的函数必须返回 `isize`
inspection.message.generic.arguments.must.come.before.first.constraint=泛型实参必须在第一个约束之前指定
inspection.message.has.been.removed=`{0}` 已被移除
inspection.message.has.been.removed2={0} has been removed
inspection.message.has.but.its.trait.declaration.has={0} `{1}` 具有 {2} 个{3}，但其特征声明具有 {4} 个{5}
inspection.message.identifier.bound.more.than.once.in.same.pattern=标识符 `{0}` 在同一模式中被多次绑定
inspection.message.identifier.bound.more.than.once.in.this.parameter.list=标识符 `{0}` 在此形参列表中被多次绑定
inspection.message.impl.trait.not.allowed.in.path.parameters=不允许在路径形参中使用 `impl Trait`
inspection.message.impl.trait.not.allowed.outside.function.inherent.method.return.types=不允许在函数或固有方法返回值类型之外使用 `impl Trait`
inspection.message.implementing.trait.not.unsafe=实现特征 `{0}` 并非不安全
inspection.message.in.expressions.can.only.be.used.on.left.hand.side.assignment=在表达式中，`_` 只能用在赋值的左侧
inspection.message.in.this.pattern.redundant=此模式中的 `{0}\:` 冗余
inspection.message.inclusive.ranges.must.be.bounded.at.end.b.or.b=包含范围必须有结束边界(`..\=b` or `a..\=b`)
inspection.message.incorrect.meta.item=元条目不正确
inspection.message.incorrect.repr.align.attribute.format=`repr(align)` 特性格式不正确
inspection.message.incorrect.visibility.restriction=可见性限制不正确
inspection.message.inherent.impls.cannot.be.unsafe=固有 impl 不得为 unsafe
inspection.message.invalid.abi.found=无效的 ABI\: 找到了 {0}
inspection.message.invalid.crate.type.value=`crate_type` 值无效
inspection.message.invalid.dyn.keyword=`dyn` 关键字无效
inspection.message.invalid.format.string=格式字符串无效
inspection.message.invalid.format.string.expected.if.you.intended.to.print.symbol.you.can.escape.it.using=无效的格式字符串\: 应为 }。\n如果您打算打印 `{` 符号，可以使用 `{{` 对其进行转义
inspection.message.invalid.format.string.unmatched=格式字符串无效\: 不匹配的 '}'
inspection.message.invalid.label.name=标签名称 `{0}` 无效
inspection.message.invalid.path.self.super.are.allowed.only.at.beginning=无效路径\: self 和 super 仅允许出现在开头
inspection.message.invalid.predicate=谓词 `{0}` 无效
inspection.message.invalid.reference.to.positional.argument=对位置实参 {0} 的引用无效({1})
inspection.message.invalid.suffix.for.suffix.must.be.one={1} 的后缀 ''{0}'' 无效；后缀必须为其中之一\: {2}
inspection.message.invalid.version.requirement=版本要求 {0} 无效
inspection.message.it.not.allowed.to.cast.to.bool=不允许转换为布尔值。
inspection.message.item.associated.which.doesn.t.match.its.trait=条目 `{0}` 是关联 {1}，与其特征 `{2}` 不匹配
inspection.message.let.expressions.are.not.supported.here=这里不支持 `let` 表达式
inspection.message.let.expressions.in.this.position.are.unstable=此位置的 `let` 表达式不稳定
inspection.message.lifetime.name.declared.twice.in.same.scope=生命周期名称 `{0}` 在同一作用域内声明了两次
inspection.message.lifetimes.cannot.use.keyword.names=生命周期不能使用关键字名称
inspection.message.literal.out.of.range=文字 `{0}` 不适合类型 `{1}`
inspection.message.main.function.not.allowed.to.have.generic.parameters=`main` 函数不允许有泛型形参
inspection.message.main.function.not.found.in.crate=在 crate `{0}` 中找不到 `main` 函数
inspection.message.main.is.async=`{0}` 函数不允许为 `async`
inspection.message.malformed.attribute.input=`{0}` 特性输入格式错误
inspection.message.malformed.attribute.input.missing.parentheses=`{0}` 特性输入格式错误\: 缺少圆括号
inspection.message.manual.implementations.are.experimental=`{0}` 的手动实现为实验性
inspection.message.match.expression.has.unnecessary.parentheses=匹配表达式有不必要的圆括号
inspection.message.match.must.be.exhaustive=匹配必须详尽
inspection.message.may.only.be.used.inside.loop.while.blocks=`{0}` 只能在 `loop` 和 `while` 块内使用
inspection.message.method=方法
inspection.message.method.has.but.declaration.in.trait.has=方法 `{0}` 具有 {1} 个{2}，但特征 `{3}` 中的声明具有 {4} 个
inspection.message.method.has.declaration.in.impl.but.not.in.trait=方法 `{0}` 在 impl 中具有 `{1}` 声明，但在特征中没有
inspection.message.method.has.declaration.in.trait.but.not.in.impl=方法 `{0}` 在特征中具有 `{1}` 声明，但在 impl 中没有
inspection.message.methods.called.usually.take.consider.choosing.less.ambiguous.name=名为 `{0}*{1}` 的方法通常接受{2}。考虑选择一个更明确的名称
inspection.message.mismatched.types=不匹配的类型
inspection.message.missing.features=缺少功能\: {0}
inspection.message.missing.lifetime.specifier=缺少生命周期说明符
inspection.message.missing.type.for.item=`{0}` 条目缺少类型
inspection.message.multiple.attributes=多个 ''{0}'' 特性
inspection.message.multiple.items=多个 `{0}` 条目
inspection.message.multiple.patterns.in.if.let.while.let.are.unstable=`if let` 和 `while let` 中的多个模式不稳定
inspection.message.must.be.declared.prior.to={0} {1} 必须在 {2} {3} 之前声明
inspection.message.must.be.last.in.argument.list.for.variadic.function=`...` 必须位于可变函数实参列表的最后
inspection.message.must.have.body={0} 必须有主体
inspection.message.must.have.body2={0} 必须有主体
inspection.message.must.have.value={0} 必须有值
inspection.message.must.have.value2={0} 必须有值
inspection.message.mutable=可变
inspection.message.name.already.used.for.generic.parameter.in.this.item.s.generic.parameters=名称 `{0}` 已在此条目的泛型形参中用作泛型形参
inspection.message.name.defined.multiple.times=名称 `{0}` 被多次定义
inspection.message.named.argument.never.used=命名实参从未使用
inspection.message.negative.implementations.are.not.unsafe=否定实现并非 unsafe
inspection.message.nested.impl.trait.not.allowed=不允许使用嵌套 `impl Trait`
inspection.message.nested.quantification.lifetimes=生命周期的嵌套量化
inspection.message.newer.version.available.for.crate=有较新版本的 crate {0} 可用\: {1}
inspection.message.no.arguments.were.given=没有给定任何实参
inspection.message.no.such.field=没有此类字段
inspection.message.no.version.matching.found.for.crate=找不到 crate {1} 的与 {0} 匹配的版本
inspection.message.non.constant.value.was.used.in.constant.expression=在常量表达式中使用了非常量值
inspection.message.non.string.abi.literal=非字符串 ABI 文字
inspection.message.not.all.trait.items.implemented.missing=未实现所有特征条目，缺少\: {0}
inspection.message.not.member.trait={0} `{1}` 不是特征 `{2}` 的成员
inspection.message.only.auto.traits.can.be.used.as.additional.traits.in.trait.object=只有自动特征可以用作特征对象中的附加特征
inspection.message.only.single.explicit.lifetime.bound.permitted=只允许单个显式生命周期边界
inspection.message.only.static.constants.are.allowed.in.extern.blocks=extern 块中只允许使用 static 常量
inspection.message.only.traits.defined.in.current.crate.can.be.implemented.for.arbitrary.types=只有在当前 crate 中定义的特征才能为任意类型实现
inspection.message.parameter.never.used=形参 `{0}` 从未使用
inspection.message.parenthesized.lifetime.bounds.are.not.supported=不支持带圆括号的生命周期边界
inspection.message.parenthetical.notation.only.stable.when.used.with.fn.family.traits=圆括号表示法仅在与 `Fn` 系列特征一起使用时才稳定
inspection.message.pattern.does.not.correspond.to.its.declaration.expected.found={0} 模式与其声明不对应\: 应为 {1} 个{2}，实际为 {3} 个
inspection.message.pattern.does.not.mention={0} 模式未提及{1} {2}
inspection.message.patterns.aren.t.allowed.in.foreign.function.declarations=不允许在外部函数声明中使用模式
inspection.message.patterns.aren.t.allowed.in.function.pointer.types=不允许在函数指针类型中使用模式
inspection.message.patterns.aren.t.allowed.in.functions.without.bodies=不允许在没有主体的函数中使用模式
inspection.message.positional.arguments.cannot.follow.named.arguments=位置实参不能跟在命名实参后面
inspection.message.precise.format.fn.family.traits.type.parameters.subject.to.change=`fn` 系列特征类型形参的精确格式可能会发生变化
inspection.message.predicate.expression.has.unnecessary.parentheses=谓词表达式有不必要的圆括号
inspection.message.println.macro.invocation.can.be.simplified=println\! 宏调用可简化
inspection.message.private={0} `{1}` 为 private
inspection.message.private.cannot.be.re.exported=`{0}` 为 private，无法重新导出
inspection.message.provided.when.constant.was.expected=应为常量时提供了{0}
inspection.message.provided.when.lifetime.was.expected=应为生命周期时提供了{0}
inspection.message.provided.when.type.was.expected=应为类型时提供了{0}
inspection.message.range.to.patterns.with.are.not.allowed=不允许使用带有 `...` 的范围结尾模式
inspection.message.recursion.in.async.fn.requires.boxing=`async fn` 中的递归需要装箱
inspection.message.redundant=冗余的 `\:\:`
inspection.message.redundant.else=冗余的 `else`
inspection.message.redundant.parentheses.in.expression=表达式中存在冗余圆括号
inspection.message.repr.inttype.must.be.specified=必须指定 `\#[repr(inttype)]`
inspection.message.requires.unsafe.impl.declaration.due.to.attribute=由于 `\#[{0}]` 特性，需要 `unsafe impl` 声明
inspection.message.reserved.keyword=`{0}`是保留关键字
inspection.message.reserved.keyword.in.edition=`{0}`是 2018 版中的保留关键字
inspection.message.reserved.lifetime.name=`{0}` 是保留的生命周期名称
inspection.message.return.can.be.lifted.out=可从 ''{0}'' 中提取出返回值
inspection.message.return.expression.has.unnecessary.parentheses=返回表达式有不必要的圆括号
inspection.message.return.in.function.whose.return.type.not=在返回值类型不是 `()` 的函数中使用了 `return;`
inspection.message.rust.has.no.incdec.operator=Rust 没有 {0} 运算符
inspection.message.self.import.appears.more.than.once.in.list=`self` import 在列表中多次出现
inspection.message.self.import.can.only.appear.in.import.list.with.non.empty.prefix=`self` import 只能出现在带有非空前缀的导入列表中
inspection.message.self.imports.are.only.allowed.within.list=仅允许在 { } 列表中使用 `self` import
inspection.message.self.keyword.was.used.in.static.method=在 static 方法中使用了 self 关键字
inspection.message.self.value.not.available.in.this.context=self 值在上下文中不可用
inspection.message.should.have.body={0} 应有主体
inspection.message.should.have.body2={0} 应有主体`
inspection.message.should.have.case.name.such.as={0} `{1}` 应具有{2}命名法名称，例如 `{3}`
inspection.message.some.fields.are.missing=缺少某些字段
inspection.message.specifier.must.be.type.usize={0} 说明符必须是 `usize` 类型
inspection.message.start.attribute.can.be.placed.only.on.functions=起始特性只能放在函数上
inspection.message.static.constant=static 常量 `{0}`
inspection.message.static.constants.are.not.allowed.in.impl.blocks=不允许在 impl 块中使用 static 常量
inspection.message.static.constants.are.not.allowed.in.traits=不允许在特征中使用 static 常量
inspection.message.static.constants.in.extern.blocks.cannot.have.values=extern 块中的 static 常量不能有值
inspection.message.struct=结构
inspection.message.suffixed.literals.are.not.allowed.in.attributes=不允许在特性中使用后缀文字
inspection.message.suspicious.assignment.did.you.mean.or=可疑的赋值。您指的是 `{0}` 还是 `{1}`?
inspection.message.suspicious.else.if.formatting=可疑的 `else if` 格式设置
inspection.message.suspicious.if.did.you.mean.else.if=可疑的 if。您是否指的是 `else if`?
inspection.message.syntax.deprecated.use.for.exclusive.range.or.for.inclusive.range=`...` 语法已被弃用。使用 `..` 表示排除范围或使用 `..\=` 表示包含范围
inspection.message.there.are.arguments=有 {0} 个实参
inspection.message.there.argument=有 1 个实参
inspection.message.there.no.argument.named=没有名为 `{0}` 的实参
inspection.message.this.feature.only.available.in.edition=此功能仅在 2018 版中可用
inspection.message.this.function.takes.choice.at.least.but.choice.was.were.supplied=此函数需要{0, choice, 0\# 至少|1\#} {1} 个{2}，但提供了 {3} 个{4}{5, choice, 0\#|1\#}
inspection.message.trait.bound.not.satisfied=不满足特征边界 `{0}\: {1}`
inspection.message.trait.bound.std.marker.sized.not.satisfied=不满足特征边界 `{0}\: std\:\:marker\:\:Sized`
inspection.message.trait.copy.may.not.be.implemented.for.this.type=无法为此类型实现特征 `Copy`
inspection.message.trait.functions.cannot.be.declared.const=特征函数不能声明为 const
inspection.message.trait.objects.must.include.dyn.keyword=特征对象必须包含 `dyn` 关键字
inspection.message.trait.objects.without.explicit.dyn.are.deprecated=没有显式 'dyn' 的特征对象已弃用
inspection.message.trait.requires.unsafe.impl.declaration=特征 `{0}` 需要 `unsafe impl` 声明
inspection.message.try.macro.can.be.replaced.with.operator=try\! 宏可被替换为 ? 运算符
inspection.message.tuple.struct=元组结构
inspection.message.type=类型
inspection.message.type.0=类型 `{0}`
inspection.message.type.cannot.be.dereferenced=类型 {0} 无法取消引用
inspection.message.type.cant.be.indexed.by=类型 `{0}` 无法由 `{1}` 编制索引
inspection.message.type.parameter.has.more.than.one.relaxed.default.bound.only.one.supported=类型形参有多个宽松的默认边界，仅支持一个
inspection.message.type.parameters.with.default.must.be.trailing=具有默认值的类型形参必须为尾随
inspection.message.type.placeholder.not.allowed.within.types.on.item.signatures=不允许在条目签名的类型中使用类型占位符 `_`
inspection.message.type2=类型
inspection.message.unclosed=未闭合的 {0}
inspection.message.unexpected=意外 `...`
inspection.message.unexpected2=意外 `..\=`
inspection.message.unexpected3=意外 `..`
inspection.message.union.cannot.be.tuple.like=联合不能类似元组
inspection.message.union.expressions.should.have.exactly.one.field=联合表达式应有且只有一个字段
inspection.message.union.patterns.requires.field=联合模式需要一个字段
inspection.message.union.patterns.should.have.exactly.one.field=联合模式应有且只有一个字段
inspection.message.unknown.format.trait=未知的格式特征 `{0}`
inspection.message.unknown.meta.item=未知元条目 ''{0}''
inspection.message.unlabeled.inside.labeled.block=标记的块内有未标记的 `{0}`
inspection.message.unnecessary.cast=不必要的转换
inspection.message.unnecessary.qualification=不必要的限定
inspection.message.unnecessary.visibility.qualifier=不必要的可见性限定符
inspection.message.unreachable.code=不可到达的代码
inspection.message.unreachable.pattern=不可到达的模式
inspection.message.unrecognized.representation=无法识别的表示 {0}
inspection.message.unresolved.reference=未解析的引用\: `{0}`
inspection.message.unresolved.reference2=未解析的引用
inspection.message.unsafe.dereference.raw.pointer=原始指针的非安全取消引用
inspection.message.unstable=`{0}` 不稳定{1}
inspection.message.unused.attribute=未使用的特性
inspection.message.unused.import=未使用的 import\: `{0}`
inspection.message.unused.mut=未使用的 `mut`
inspection.message.use.moved.value=使用移动后的值
inspection.message.use.possibly.uninitialized.variable=使用可能未初始化的变量
inspection.message.use.static.unsafe.requires.unsafe.function.or.block=使用 {0} static 不安全，需要非安全函数或块
inspection.message.use.undeclared.label=使用未声明的标签 `{0}`
inspection.message.use.undeclared.lifetime.name=使用未声明的生命周期名称 `{0}`
inspection.message.use.unreachable.label=使用不可到达的标签 `{0}`
inspection.message.use.unsafe.requires.unsafe.function.or.block=使用 `{0}\!()` 不安全，需要非安全函数或块
inspection.message.use.unsafe.static=对非安全 {0} static 的使用
inspection.message.value.associated.must.be.specified=必须指定关联{0} {1}的值
inspection.message.value.was.moved.out.while.it.was.still.borrowed=值在借用时已被移出
inspection.message.variable.never.used=变量 `{0}` 从未使用
inspection.message.visibilities.can.only.be.restricted.to.ancestor.modules=可见性只能限于上级模块
inspection.message.with.no.label.in.condition.while.loop=在 `while` 循环条件中存在没有标签的 `{0}`
inspection.message.with.suffix.invalid=带后缀的 {0} 无效
inspection.message.wrong.meta.list.delimiters=元列表分隔符错误
inspection.message.wrong.number.arguments.expected.found={0} 实参数量错误\: 应为 {1} 个，但实际为 {2} 个
inspection.message.wrong.number.lifetime.arguments.expected.found=生命周期实参数量错误\: 应为 {0} 个，但实际为 {1} 个
inspection.message.x.could.be.misinterpreted.as.pre.decrement.but.effectively.no.op=--x 可能会被误解释为预减，但实际上是无运算
inspection.missing.features.display.name=缺少功能
inspection.new.crate.version.available.display.name=新的 crate 版本可用
inspection.rs.approx.constant.display.name=近似常量
inspection.rs.argument.naming.display.name=实参命名约定
inspection.rs.assert.equal.display.name=断言相等
inspection.rs.assign.to.immutable.display.name=赋值给不可变
inspection.rs.assoc.type.naming.display.name=关联类型命名约定
inspection.rs.async.main.function.display.name=入口点为 async
inspection.rs.attr.without.parentheses.display.name=不带圆括号的特性
inspection.rs.bare.trait.objects.display.name=特征对象必须包含 dyn 关键字
inspection.rs.borrow.checker.display.name=借用检查器
inspection.rs.c.string.pointer.display.name=unsafe CString 指针
inspection.rs.cast.to.bool.display.name=转换为布尔值
inspection.rs.compile.error.macro.display.name=编译错误宏
inspection.rs.const.naming.display.name=常量命名约定
inspection.rs.const.refer.static.display.name=常量引用 static
inspection.rs.constant.condition.if.display.name='if' 表达式的条件为常量
inspection.rs.dangling.else.display.name=悬空的 else
inspection.rs.deprecation.display.name=弃用的元素
inspection.rs.detached.file.display.name=分离的文件
inspection.rs.double.must.use.display.name=双重 must_use
inspection.rs.double.neg.display.name=双重求反
inspection.rs.drop.ref.display.name=丢弃引用
inspection.rs.duplicated.trait.method.binding.display.name=重复的特征方法形参名称
inspection.rs.enum.naming.display.name=枚举命名约定
inspection.rs.enum.variant.naming.display.name=枚举变体命名约定
inspection.rs.experimental.checks.display.name=实验性检查
inspection.rs.external.linter.display.name=外部 Linter
inspection.rs.extra.semicolon.display.name=额外的分号
inspection.rs.field.init.shorthand.display.name=字段初始化速记形式
inspection.rs.field.naming.display.name=字段命名约定
inspection.rs.function.naming.display.name=函数命名约定
inspection.rs.lifetime.naming.display.name=生命周期命名约定
inspection.rs.lift.display.name=可以提取出返回值
inspection.rs.literal.out.of.range.display.name=文字超出范围
inspection.rs.liveness.display.name=存活性分析
inspection.rs.macro.naming.display.name=宏命名约定
inspection.rs.main.function.not.found.display.name=找不到 main 函数
inspection.rs.method.naming.display.name=方法命名约定
inspection.rs.missing.else.display.name=缺少 else
inspection.rs.module.naming.display.name=模块命名约定
inspection.rs.needless.lifetimes.display.name=不必要的生命周期
inspection.rs.non.exhaustive.match.display.name=非穷尽匹配
inspection.rs.non.shorthand.field.patterns.display.name=非速记字段模式
inspection.rs.path.statements.display.name=路径语句
inspection.rs.reassign.immutable.display.name=重新赋值不可变变量
inspection.rs.redundant.else.display.name=冗余的 else
inspection.rs.redundant.semicolons.display.name=冗余的分号
inspection.rs.replace.cast.with.suffix.display.name=转换可被替换为文字后缀
inspection.rs.self.convention.display.name=Self 约定
inspection.rs.simplify.boolean.expression.display.name=简化布尔表达式
inspection.rs.simplify.print.display.name=println\!("") 用法
inspection.rs.sort.impl.trait.members.display.name=与特征不同的 impl 成员顺序
inspection.rs.static.const.naming.display.name=static 常量命名约定
inspection.rs.struct.naming.display.name=结构命名约定
inspection.rs.suspicious.assignment.display.name=可疑的赋值
inspection.rs.thread.rng.gen.can.be.replaced.with.random=`thread_rng().gen()` 可被替换为 `random()`
inspection.rs.trait.implementation.display.name=特征实现
inspection.rs.trait.naming.display.name=特征命名约定
inspection.rs.try.macro.display.name=try\! 宏用法
inspection.rs.type.alias.naming.display.name=类型别名命名约定
inspection.rs.type.check.display.name=类型检查器
inspection.rs.type.parameter.naming.display.name=类型参数命名惯例
inspection.rs.unknown.crate.types.display.name=未知的 crate 类型
inspection.rs.unnecessary.cast.display.name=不必要的转换
inspection.rs.unnecessary.qualifications.display.name=不必要的限定路径
inspection.rs.unreachable.code.display.name=不可到达的代码
inspection.rs.unreachable.patterns.display.name=不可到达的模式
inspection.rs.unresolved.reference.display.name=未解析的引用
inspection.rs.unused.import.display.name=未使用的 import
inspection.rs.unused.labels.display.name=未使用的标签
inspection.rs.unused.must.use.display.name=未使用的 must_use
inspection.rs.unused.mut.display.name=未使用的 mut 修饰符
inspection.rs.variable.naming.display.name=变量命名约定
inspection.rs.while.true.loop.display.name=While true 循环
inspection.rs.wrong.assoc.type.arguments.display.name=错误的关联类型实参
inspection.rs.wrong.generic.arguments.number.display.name=泛型实参数量错误
inspection.rs.wrong.generic.arguments.order.display.name=泛型实参顺序错误
inspection.rs.wrong.generic.parameters.number.display.name=类型或 const 形参数量错误
inspection.rs.wrong.lifetime.parameters.number.display.name=生命周期形参数量错误
inspection.toml.invalid.keyword.segment.display.name=无效的关键字部分
intention.Rust.ToggleFeatureIntention.disable=禁用功能 `{0}`
intention.Rust.ToggleFeatureIntention.enable=启用功能 `{0}`
intention.Rust.ToggleFeatureIntention.family.name=切换功能状态
intention.family.name.add.feature.attribute=添加 feature 特性
intention.family.name.add.fn.main=添加 `fn main()`
intention.family.name.add.import=添加 import
intention.family.name.add.import.for.path.in.pattern=在模式中添加路径导入
intention.family.name.add.label=添加标签
intention.family.name.add.missing.generic.arguments=添加缺少的泛型实参
intention.family.name.add.parentheses=添加圆括号
intention.family.name.add.safe.cast=添加安全转换
intention.family.name.add.self.to=将 self 添加到 {0}
intention.family.name.add.type=添加类型
intention.family.name.apply.suggested.replacement.made.by.external.linter=应用外部 linter 建议的替换
intention.family.name.change.function.signature=更改函数签名
intention.family.name.change.item.visibility=更改条目可见性
intention.family.name.change.name.element=更改元素名称
intention.family.name.change.repr.attribute=更改 `repr` 特性
intention.family.name.change.return.type=更改返回值类型
intention.family.name.compare.with.zero=与零比较
intention.family.name.convert.not.b.cfg.pattern.to.all.not.not.b=将 `not(a, b)` cfg-pattern 转换为 `all(not(a), not(b))`
intention.family.name.convert.to.loop=转换为循环
intention.family.name.convert.to.sized.type=转换为大小类型
intention.family.name.convert.to.type=转换为类型
intention.family.name.convert.to.unsuffixed.integer=转换为无后缀整数
intention.family.name.convert.type=转换声明类型
intention.family.name.convert.type.local.variable=转换局部变量的类型
intention.family.name.create.enum.variant=创建枚举变体
intention.family.name.create.function=创建函数
intention.family.name.create.lifetime.parameter=创建生命周期形参
intention.family.name.create.module.file=创建模块文件
intention.family.name.create.struct=创建结构
intention.family.name.create.tuple.struct=创建元组结构
intention.family.name.demorgan.s.law=德摩根定律
intention.family.name.derive.trait=派生特征
intention.family.name.do.not.show.again=不再显示
intention.family.name.enable.features=启用功能
intention.family.name.extract.inline.module.structure=提取内联模块结构
intention.family.name.import=导入
intention.family.name.lift.return=提取出返回值
intention.family.name.make.async=设为 async
intention.family.name.make.mutable=设为可变
intention.family.name.make.public=设为 public
intention.family.name.qualify.path=限定路径
intention.family.name.reload.project=重新加载项目
intention.family.name.remove=移除
intention.family.name.remove.bound=移除边界
intention.family.name.remove.parameter=移除形参
intention.family.name.remove.reference=移除引用
intention.family.name.remove.self.from=从 {0} 中移除 self
intention.family.name.remove.struct.literal.field=移除结构文字字段
intention.family.name.remove.unnecessary.cast=移除不必要的转换
intention.family.name.remove.variable=移除变量
intention.family.name.rename.element=重命名元素
intention.family.name.replace.box.with.box.new=将 `box` 替换为 `Box\:\:new`
intention.family.name.replace.cast.with.literal.suffix=将转换替换为文字后缀
intention.family.name.replace.str.index.with.chars.index=将 str 索引替换为 char 索引(&S)
intention.family.name.replace.successive.with=将连续的 `_` 替换为 `..`
intention.family.name.replace.with.block.comment=替换为块注释
intention.family.name.replace.with.end.line.comment=替换为行尾注释
intention.family.name.replace.with.inclusive.range=替换为包含范围
intention.family.name.replace.with.predefined.constant=替换为预定义常量
intention.family.name.simplify.boolean.expression=简化布尔表达式
intention.family.name.split.if=拆分 if
intention.family.name.substitute.one.text.to.another=将一个文本替换为另一个文本
intention.family.name.suppress.warnings=禁止警告
intention.family.name.unwrap.enum.or.tuple.struct.constructor.from.expression=从表达式中解包枚举或元组结构构造函数
intention.family.name.update.dependency.version=更新依赖项版本
intention.family.name.use.loop=使用 `loop`
intention.family.name.use.shorthand.field.pattern=使用速记字段模式
intention.name.={0}{1}
intention.name.add=添加 '..'
intention.name.add.as.parameter.to=将 `{0}` 作为 `{1}` 形参添加到{2} `{3}`
intention.name.add.async.recursion.attribute=添加 `async_recursion` 特性
intention.name.add.braces.to.lambda.expression=向 lambda 表达式添加大括号
intention.name.add.curly.braces=添加大括号
intention.name.add.definition.to.trait=为特征添加定义
intention.name.add.derive.clause=添加派生子句
intention.name.add.derive.to=将 `\#[derive({0})]` 添加到 `{1}`
intention.name.add.dummy.parameter.name=添加虚拟形参名称
intention.name.add.dyn.keyword.to.trait.object=将 'dyn' 关键字添加到特征对象
intention.name.add.else.branch.to.this.if.statement=将 else 分支添加到此 if 语句
intention.name.add.feature=添加 `{0}` 功能
intention.name.add.field.to.struct=将字段 `{0}` 添加到类型 `{1}`
intention.name.add.format.string=添加格式字符串
intention.name.add.format.string.argument=添加格式字符串实参
intention.name.add.impl.block=添加 impl 块
intention.name.add.import.for=为 `{0}` 添加 import
intention.name.add.missing=添加缺失的{0}
intention.name.add.missing.associated.types=添加缺少的关联类型
intention.name.add.missing.fields=添加缺少的字段
intention.name.add.parentheses.to=将圆括号添加到 `{0}`
intention.name.add.pattern=添加 _ 模式
intention.name.add.remaining.patterns=添加剩余的模式
intention.name.add.safe.cast.to=添加到 {0} 的安全转换
intention.name.add.self.to.function=将 self 添加到函数
intention.name.add.tokio.main=添加 `\#[tokio\:\:main]`
intention.name.add.turbofish.operator=添加 turbofish 运算符
intention.name.add.type=添加类型 {0}
intention.name.add.unsafe.to=将 unsafe 添加到 {0}
intention.name.apply.same.member.order=应用相同的成员顺序
intention.name.attach.file.to=将文件附加到{0}
intention.name.b.b=<b>{0}</b>
intention.name.b.b2=<b>{0}</b>
intention.name.block=阻塞
intention.name.change.format.parameter.to=将格式形参更改为 `{\:?}`
intention.name.change.reference.to.mutable=更改对可变变量的引用
intention.name.change.representation.enum.to.repr=将枚举 `{0}` 的表示更改为 `\#[repr({1})]`
intention.name.change.return.type.to=将返回值类型{0}{1} 更改为 `{2}`
intention.name.change.to=更改为 `{0}`
intention.name.change.to.else.if=更改为 `else if`
intention.name.change.to1=更改为 {0}
intention.name.change.to2=更改为 `{0}`
intention.name.change.to3=更改为 `{0}`
intention.name.change.try.to=将 try\! 更改为 ?
intention.name.change.type.to=将{1} `{2}` 中 {0} 的类型更改为 `{3}`
intention.name.change.type.to2=将`{0}`的类型更改为`{1}`
intention.name.convert.closure.to.function=将闭包转换为函数
intention.name.convert.function.to.closure=将函数转换为闭包
intention.name.convert.if.let.statement.to.match=将 if let 语句转换为 match
intention.name.convert.impl.trait.to.type.parameter=将 `impl Trait` 转换为类型形参
intention.name.convert.match.statement.to.if.let=将 match 语句转换为 if let
intention.name.convert.to=转换为 `{0}`
intention.name.convert.to.box=转换为 Box
intention.name.convert.to.macro=转换为 {0}\!
intention.name.convert.to.method.call=转换为方法调用
intention.name.convert.to.reference=转换为引用
intention.name.convert.to.struct=转换为结构
intention.name.convert.to.tuple=转换为元组
intention.name.convert.to.ufcs=转换为 UFCS
intention.name.convert.to.using=使用 {1}转换为 {0}
intention.name.create.associated.function=创建关联函数 `{0}\:\:{1}`
intention.name.create.associated.function.self=创建关联函数 `Self\:\:{0}`
intention.name.create.enum.variant=创建枚举变体 `{0}`
intention.name.create.field=创建字段
intention.name.create.function=创建函数 `{0}`
intention.name.create.method=创建方法 `{0}`
intention.name.create.module.file=创建模块文件 `{0}`
intention.name.create.struct=创建结构 `{0}`
intention.name.create.tuple.struct=创建元组结构 `{0}`
intention.name.delete.expression=删除表达式
intention.name.demorgan.s.law.replace.with=德摩根定律，将 '||' 替换为 '&&'
intention.name.demorgan.s.law.replace.with2=德摩根定律，将 '&&' 替换为 '||'
intention.name.derive.copy.trait=派生 Copy 特征
intention.name.derive.debug.and.replace.display.to.debug=派生 `{0}` 的 `Debug` 并将 `'{}'` 替换为 `'{\:?}'`
intention.name.elide.lifetimes=省略生命周期
intention.name.enclose.expression.in.braces=将表达式括在大括号中
intention.name.escape.keyword=转义关键字
intention.name.escape.reserved.keyword=转义保留关键字
intention.name.expand.dependency.specification=展开依赖项规范
intention.name.external.linter=外部 Linter\: {0}
intention.name.extract.enum.variant=提取枚举变体
intention.name.extract.inline.module=提取内联模块
intention.name.fill.missing.arguments=填充缺少的实参
intention.name.fix.visibility.restriction=修正可见性限制
intention.name.flatten.use.statements=平展 use 语句
intention.name.flip=翻转 ''{0}''
intention.name.flip.binary.expression=翻转二元表达式
intention.name.flip.changes.semantics=翻转 ''{0}'' (更改语义)
intention.name.flip.to=将 ''{0}'' 翻转为 ''{1}''
intention.name.function=函数
intention.name.generate.documentation.stub=生成文档存根
intention.name.html.change.signature.to.html=<html>将签名更改为 {0}({1})</html>
intention.name.impl=impl
intention.name.implement.display.trait.for=为 `{0}` 实现 `Display` 特征
intention.name.implement.members=实现成员
intention.name.implement.missing.supertrait.s=实现缺少的超特征
intention.name.implement.trait=实现特征
intention.name.import=导入
intention.name.initialize.with.default.value=使用默认值初始化
intention.name.install.tokio.and.add.main=将 tokio 添加到依赖项并添加 `\#[tokio\:\:main]`
intention.name.introduce.local.variable=引入局部变量
intention.name.invert.if.condition=反转 if 条件
intention.name.join.else.if=加入 `else if`
intention.name.lambda=lambda
intention.name.lift.return.out=从 ''{0}'' 中提取返回
intention.name.make=将 {0} 设为 {1}
intention.name.make.async=将 {0} 设为 async
intention.name.make.mutable=将 `{0}` 设为可变
intention.name.make.public=将 `{0}` 设为 public
intention.name.merge.with.nested.if.expression=与嵌套的 `if` 表达式合并
intention.name.method=方法
intention.name.move.guard.inside.match.arm=将 guard 移至 match arm 内
intention.name.move.type.constraint.to.parameter.list=将类型约束移至形参列表
intention.name.move.type.constraint.to.where.clause=将类型约束移至 where 子句
intention.name.nest.use.statements=嵌套使用语句
intention.name.put.arguments.on.one.line=将实参放在同一行中
intention.name.put.arguments.on.separate.lines=将实参放在单独的行中
intention.name.put.fields.on.one.line=将字段放在一行中
intention.name.put.fields.on.separate.lines=将字段放在单独的行中
intention.name.put.parameters.on.one.line=将形参放在同一行中
intention.name.put.parameters.on.separate.lines=将形参放在单独的行中
intention.name.put.variants.on.one.line=将变体放在一行中
intention.name.put.variants.on.separate.lines=将变体放在单独的行中
intention.name.qualify.path.to=将路径限定为 `{0}`
intention.name.recursively.add.missing.fields=递归添加缺少的字段
intention.name.recursively.replace.with.actual.fields=将 .. 递归替换为实际字段
intention.name.remove=移除 {0}
intention.name.remove.as=移除 `as {0}`
intention.name.remove.bound=移除 {0} 边界
intention.name.remove.braces.from.single.expression=从单个表达式中移除大括号
intention.name.remove.braces.from.single.expression.statement=从表达式语句中移除大括号
intention.name.remove.curly.braces=移除大括号
intention.name.remove.dbg=移除 dbg\!
intention.name.remove.else=移除 `else`
intention.name.remove.from=从 {1} `{2}` 中移除 {0}
intention.name.remove.parameter=移除形参 `{0}`
intention.name.remove.parentheses.from.expression=从表达式中移除圆括号
intention.name.remove.quotes=移除引号
intention.name.remove.redundant.arguments=移除冗余参数
intention.name.remove.redundant.associated.type=移除冗余的关联类型
intention.name.remove.redundant.generic.arguments=移除冗余的泛型实参
intention.name.remove.semicolon=移除分号
intention.name.remove.suffix=移除后缀
intention.name.remove.unnecessary.argument=移除不必要的实参
intention.name.remove.unnecessary.path.prefix=移除不必要的路径前缀
intention.name.remove.unreachable.code=移除不可到达的代码
intention.name.remove.unreachable.match.arm=移除不可到达的 match arm
intention.name.remove.unreachable.pattern=移除不可到达的模式
intention.name.remove.unused.import=移除未使用的 import
intention.name.remove.variable=移除变量 `{0}`
intention.name.remove2=移除 {0}
intention.name.rename.to=重命名为 `{0}`
intention.name.replace.brackets=替换中括号
intention.name.replace.inc.dec.operator=替换为 `{0}`
intention.name.replace.unwrap.with.match=将 .unwrap() 替换为 match
intention.name.replace.unwrap.with.try=将 .unwrap() 替换为 try
intention.name.replace.with=将 `_` 替换为 `..`
intention.name.replace.with.0.1=替换为 `{0}{1}`
intention.name.replace.with.actual.fields=将 .. 替换为实际字段
intention.name.replace.with.std.mem.drop=替换为 `std\:\:mem\:\:drop`
intention.name.replace.with2=替换为 `{0}`
intention.name.set.reference.immutable=将引用设置为不可变
intention.name.set.reference.mutable=将引用设置为可变
intention.name.show.recursive.macro.expansion=显示递归宏展开
intention.name.show.result.macro.expansion.cargo.expand=显示宏展开的结果(cargo Expand)
intention.name.show.single.step.macro.expansion=显示单步宏展开
intention.name.simplify.boolean.expression=简化布尔表达式
intention.name.simplify.dependency.specification=简化依赖项规范
intention.name.simplify.expression=简化表达式
intention.name.specify.type.explicitly=明确地指定类型
intention.name.split.into.if.s=拆分为 2 个 'if'
intention.name.substitute=替换
intention.name.substitute.type.alias=替换类型别名
intention.name.suppress.all.inspections.for.item=禁止条目的所有检查
intention.name.suppress.for=禁止{1}的 `{0}`
intention.name.suppress.for.item.with.comment=禁止带有注释的条目
intention.name.surround.with.unsafe.block=使用 unsafe 块包围
intention.name.toggle.ignore.for.tests=切换测试的 ignore
intention.name.un.elide.lifetimes=取消省略生命周期
intention.name.unwrap.from.expression=从表达式中解包 `{0}`
intention.name.update.version.to=将版本更新到 {0}
intention.name.use.destructuring.declaration=使用析构声明
intention.name.use.drop.to.clarify.intent.drop=使用 `drop` 澄清意图\: `drop({0});`
intention.name.use.initialization.shorthand=使用初始化速记形式
intention.name.use.shorthand.field.pattern=使用速记字段模式\: `{0}`
introduce.parameter.to.method=将参数引入方法
invalid.rust.toolchain.0=无效的 Rust 工具链 {0}
invalid.rust.toolchain.02=无效的 Rust 工具链 {0}
invalid.standard.library.0=无效的标准库\: {0}
irrefutable.let.pattern=不可反驳的 let 模式
iso.8601.rfc.3339.date.time.format.2001.07.08t00.34.60.026490.09.30=(2001-07-08T00\:34\:60.026490+09\:30) ISO 8601 / RFC 3339 日期和时间格式
item.and.impls=条目和 impl
label.={0} {1} {2}
label.2={0} {1} {2}
label.attribute=特性
label.channel=通道(&H)\:
label.everything=所有内容
label.expression=表达式
label.install.cargo.generate.using.cargo=使用 Cargo 安装 cargo-generate
label.item=条目
label.methods.only=仅方法
label.module=模块
label.on.block=块上的标签
label.rust=Rust
label.rust.files=Rust 文件
label.statement=语句
label.struct=结构 {0}'{'
label.structure=结构
label.trait.name=特征名称\:
label.type.alias=类型别名 {0}
let.else=let else
lints=Lint
list.item.binary.application=二进制文件(应用程序)
list.item.empty.file=空文件
list.item.function.to.inline=要内联的函数
list.item.library=库
list.item.procedural.macro=过程宏
list.item.to.inline=要内联的{0}
list.item.type.alias.to.inline=要内联的类型别名
list.item.webassembly.lib=WebAssembly Lib
literal.newline.n=文字换行符(\\n)
literal.percent.sign=文字百分号
literal.tab.t=文字制表符(\\t)
local.time.zone.name.skips.all.non.whitespace.characters.during.parsing.acst=(ACST)本地时区名称。在解析过程中跳过所有非空白字符
locale.s.date.and.time.thu.mar.3.23.05.25.2005=(Thu Mar 3 23\:05\:25 2005)区域设置的日期和时间
locale.s.date.representation.12.31.99=(12/31/99)区域设置的日期表示
locale.s.time.representation.23.13.48=(23\:13\:48)区域设置的时间表示
macro=`宏`
macro.expansion.error.BuiltinMacroExpansionError.message=不支持内置宏展开
macro.expansion.error.CfgDisabled.message=使用 `\#[cfg()]` 特性有条件地禁用宏调用
macro.expansion.error.DeclMacroExpansionError.DefSyntax.message=宏定义语法中存在错误
macro.expansion.error.DeclMacroExpansionError.Matching.message=无法将宏调用主体与宏定义模式进行匹配
macro.expansion.error.DeclMacroExpansionError.TooLargeExpansion.message=宏展开太大
macro.expansion.error.ExpansionFileNotFound.message=宏尚未展开
macro.expansion.error.ExpansionNameNotFound.message=内部错误\: 未找到展开名称
macro.expansion.error.FileIncludedIntoMultiplePlaces.message=包括包含在多个位置的文件；IntelliJ-Rust 仅支持包含到一个位置
macro.expansion.error.IncludingFileNotFound.message=找不到包含文件
macro.expansion.error.InconsistentExpansionCacheAndVfs.message=内部错误\: 未找到展开文件，但缓存包含有效的展开
macro.expansion.error.InconsistentExpansionExpandedFrom.message=内部错误\: `macro.expansion.expandedFrom \!\= macro`；也许宏调用位于与另一个模块名称冲突的模块内部?
macro.expansion.error.MacroCallSyntax.message=宏调用语法中存在错误
macro.expansion.error.MacroDefSyntax.message=宏定义语法中存在错误
macro.expansion.error.MacroExpansionEngineIsNotReady.message=宏展开引擎尚未就绪
macro.expansion.error.MacroExpansionIsDisabled.message=宏展开在项目设置中禁用
macro.expansion.error.MemExpAttrMacro.message=旧的宏展开引擎无法展开特性或派生宏
macro.expansion.error.MemExpParsingError.message=无法将 `{0}` 解析为 `{1}`
macro.expansion.error.ModDataNotFound.message=内部错误\: 找不到包含宏调用 mod 的 ModData
macro.expansion.error.NoMacroIndex.message=找不到宏调用的宏索引
macro.expansion.error.NoProcMacroArtifact.message=过程宏未成功编译
macro.expansion.error.OldEngineStd.message=旧的宏展开引擎无法在 Rust stdlib 中展开宏
macro.expansion.error.ProcMacroExpansionError.CantRunExpander.message=创建 `{0}` 进程期间发生错误；查看日志以获取更多详细信息
macro.expansion.error.ProcMacroExpansionError.ExecutableNotFound.message=未找到 `{0}` 可执行文件；(也许 IntelliJ-Rust 没有为您的平台提供该文件)
macro.expansion.error.ProcMacroExpansionError.IOExceptionThrown.message=与 proc 宏展开服务器通信时抛出异常；查看日志以获取更多详细信息
macro.expansion.error.ProcMacroExpansionError.ProcMacroExpansionIsDisabled.message=过程宏展开未启用
macro.expansion.error.ProcMacroExpansionError.ProcessAborted.message=过程宏展开器进程意外退出，代码为 {0}
macro.expansion.error.ProcMacroExpansionError.ServerSideError.message=出现过程宏错误\:\n{0}
macro.expansion.error.ProcMacroExpansionError.Timeout.message=已超过程序宏展开超时({0} 毫秒)
macro.expansion.error.ProcMacroExpansionError.UnsupportedExpanderVersion.message=IntelliJ Rust 无法使用您的 Rust 工具链版本展开过程宏。这个版本似乎太新了。请考虑将 Rust 工具链降级到以前的版本或尝试更新 IntelliJ Rust 插件。(不支持的宏展开器版本 {0})
macro.expansion.error.Skipped.message=IntelliJ-Rust 跳过了此过程宏的展开
macro.expansion.error.TooDeepExpansion.message=已达到递归限制
macro.expansion.error.TooLargeExpansion.message=宏展开太大
macro.expansion.error.UnmatchedProcMacroKind.message=`{0}` proc 宏不能作为 `{1}` 调用
macro.expansion.error.Unresolved.message=宏未解析
macro.expansion.error.VirtualFileFoundButPsiIsNull.message=内部错误\: 找到了展开文件，但未找到 PSI 文件
macro.expansion.error.VirtualFileFoundButPsiIsUnknown.message=内部错误\: 找到了展开文件，但 PSI 文件未知
macro.expansion.error.start=无法展开宏\: {0}
min.const.generics=min const generics
minute.number.00.59.zero.padded.to.2.digits=(00-59)分钟数字，在前面填充零，变成 2 位数
missing.else=缺少 else
mod.0=mod {0}
mod.statements.in.non.mod.rs.files=非 mod.rs 文件中的 mod 语句
monday.1.tuesday.2.sunday.7.iso.8601=(1)星期一 \= 1、星期二 \= 2、…、星期日 \= 7。(ISO 8601)
month.day.year.format.same.as.m.d.y=(07/08/01)月-日-年格式。与 %m/%d/%y 相同
month.number.01.12.zero.padded.to.2.digits.07=(07)月份数字(01?12)，在前面填充零，变成 2 位数
name=姓名
name2=名称\:
naming.conventions=命名约定
no.explicit.stdlib.or.rustup.found=未找到显式 stdlib 或 rustup
no.lines.covered=未覆盖任何行
no.mutable.required=不需要可变
non.exhaustive.match=非穷尽匹配
notification.0.action.is.not.available.for.1.command={0} 操作不适用于 `{1}` 命令
notification.action.attach.manually.text=手动附加
notification.action.attach.text=附加
notification.action.do.not.show.again.text=不再显示
notification.action.set.up.toolchain.text=设置工具链
notification.can.not.attach.stdlib.sources=在没有 rustup 的情况下无法自动附加 stdlib 源
notification.content.bad.answer.from.crates.io=来自 crates.io 的错误答案
notification.content.cannot.load.rustc.renderers=无法加载 rustc 呈现器
notification.content.cannot.load.rustc.sources=无法加载 rustc 源
notification.content.cargo.at=Cargo 位于 {0}
notification.content.cargo.expand=cargo-expand
notification.content.choice.with={0}{2, choice, 0\#|1\#，{1}}
notification.content.could.not.create.mod=无法创建 `mod {0}`
notification.content.could.not.reach.crates.io=无法访问 crates.io
notification.content.debugger.downloading.failed=调试器下载失败
notification.content.debugger.successfully.downloaded=调试器已成功下载
notification.content.failed.to.find.stdlib.in.sysroot=在 sysroot 中找不到 stdlib
notification.content.failed.to.install.cargo.generate=无法安装 cargo-generate
notification.content.grcov=grcov
notification.content.in=\ (在 {0} 内)
notification.content.incompatible.toml.plugin.version.code.completion.for.cargo.toml.not.available=TOML 插件版本不兼容。Cargo.toml 的代码补全不可用。
notification.content.low.performance.due.to.rust.external.linter.nbsp.nbsp.nbsp.nbsp=Rust 外部 linter 导致性能低下 {0}{1}&nbsp;&nbsp;&nbsp;&nbsp;{2}
notification.content.need.at.least=至少需要 {0} {1}
notification.content.need.at.least2=至少需要 {0} {1}
notification.content.need.at.least3=至少需要 {0} {1}
notification.content.need.at.least4=至少需要 {0} {1}
notification.content.not.installed=未安装 {0}
notification.content.project.not.found=找不到项目
notification.content.rebuilt.defmap.for.all.crates.in.ms=在 {0} 毫秒内为所有 crate 重建 DefMap
notification.content.rust.toolchain.no.longer.supported=Rust <b>{0}</b> 不再受支持。这可能会导致意外错误。考虑将您的工具链至少升级到 <b>{1}</b>
notification.content.rustup=rustup
notification.content.rustup.failed=rustup 失败\: `{0}`
notification.content.rustup.failed2=rustup 失败\: `{0}`
notification.content.target.not.installed=未安装 {0} 目标
notification.content.using=正在使用{0}
notification.content.wasm.pack=wasm-pack
notification.file.not.belong.to.cargo.project=该文件不属于任何已知的 Cargo 项目
notification.group.rust.plugin=
notification.invalid.stdlib.source.path="无效的 Rust 标准库源路径\: `{0}`
notification.no.cargo.projects.found=找不到 Cargo 项目
notification.no.toolchain.configured=未配置 Rust 工具链
notification.run.tests.as.root.unix=尚不支持使用 root 权限运行测试
notification.run.tests.as.root.windows=尚不支持使用管理员权限运行测试
notification.title.code.code.not.installed=<code>{0}</code> 未安装
notification.title.debugger=调试器
notification.title.potentially.inconsistent.build.test.results=构建/测试结果可能不一致
notification.title.rustfmt=Rustfmt
off=关闭
offset.from.the.local.time.to.utc.with.seconds.09.30.00=(+09\:30\:00)本地时间与 UTC 的偏移，带秒
offset.from.the.local.time.to.utc.with.utc.being.0000=(+0000)本地时间与 UTC 的偏移
offset.from.the.local.time.to.utc.without.minutes.09=(+09)本地时间与 UTC 的偏移，不带分钟
on=开启
or.patterns.syntax=or 模式语法
parameters=形参\:
parsing.error.expected=应为 ''{0}''
parsing.error.expected.got=应为“;”，实际为 ''{0}''
parsing.error.expected.got2=应为“;”，实际为 ''{0}''
parsing.error.expected2=应为 ''{0}''
parsing.error.macro.argument.expected.got=应为 <macro argument>，实际为 ''{0}''
parsing.only.same.as.z.but.allows.minutes.to.be.missing.or.present=仅解析\: 与 %z 相同，但允许分钟数缺失或存在
popup.title.choose.module.declaration=选择模块声明
popup.title.choose.scope.to.introduce.constant=选择引入常量 {0} 的作用域
popup.title.first.level.expansion={0} 的一级扩展
popup.title.item.to.import=要导入的条目
popup.title.macro={0}\! 宏
popup.title.recursive.expansion={0} 的递归扩展
previous.command.is.still.running.please.wait.or.press.ctrl.c.in.console.to.interrupt=上一个命令仍在运行。请等待或在控制台中按 Ctrl C 以中断运行。
println.usage=println\!("") 用法
private=不公开
progress.text.building=正在构建…
progress.text.building1=正在构建…
progress.text.connecting.to.console=正在连接到控制台…
progress.text.getting.rust.stdlib=正在获取 Rust 标准库
progress.text.getting.toolchain.version=正在获取工具链版本
progress.text.info=信息\:
progress.text.installing.using.cargo=正在使用 Cargo 安装…
progress.text.preparing.resolve.data=正在准备解析数据
progress.text.save.macro.expansions=保存宏展开
progress.text.updating.workspace.info=正在更新工作区信息
progress.text.waiting.for.current.build.to.finish=正在等待当前构建完成…
progress.title.analyzing.project.with=正在使用 {0} 分析项目…
progress.title.build=构建
progress.title.building=正在构建…
progress.title.building.cargo.project=正在构建 Cargo 项目
progress.title.checking.if.installed=正在检查 {0} 是否安装…
progress.title.checking.if.toolchain.supported=正在检查是否支持工具链…
progress.title.choice.recursive.single.step.expansion.progress=正在进行{0, choice, 0\#递归|1\#单步}展开…
progress.title.cleaning.outdated.macros=正在清理过时的宏
progress.title.connecting.to.console=连接控制台
progress.title.expanding.rust.macros=正在展开 Rust 宏
progress.title.generating.cargo.project=正在生成 Cargo 项目…
progress.title.getting.environment.variables=正在获取环境变量…
progress.title.getting.installed.distributions=正在安装分发版…
progress.title.installing=正在安装 {0}…
progress.title.installing2=正在安装 {0}…
progress.title.loading.cargo.registry.index=正在加载 Cargo 注册表索引
progress.title.loading.coverage.data=正在加载覆盖率数据...
progress.title.preparing.remote.environment=正在准备远程环境…
progress.title.reformatting.cargo.project.with.rustfmt=正在使用 Rustfmt 重新设置 Cargo 项目的格式…
progress.title.reloading.cargo.projects=正在重新加载 Cargo 项目
progress.title.restarting.console=正在重启控制台
public=公开
quick.doc.expansion.is.unavailable=展开在快速文档中不可用。请考虑使用意图操作。
quick.doc.macro.expansion=宏展开
radio.inline.all.keep.method=全部内联并保留方法
radio.inline.all.references.keep=内联所有引用并保留 {0}
radio.inline.all.remove.type.alias=全部内联并移除类型别名
radio.inline.this.only.keep=仅内联此项并保留 {0}
radio.inline.this.only.keep.type.alias=仅内联此项并保留类型别名
raw.address.of.syntax=`raw address of` 语法
redundant.else=冗余的 else
refactoring.change.signature.error.cfg.disabled.parameters=无法更改具有禁用 cfg 形参的函数的签名
refactoring.change.signature.name=更改签名
refactoring.change.signature.name.conflict=名称 {0} 与 {1} 中的现有条目冲突
refactoring.change.signature.refactor.super.function=方法 {0} 实现特征 {1} 的基方法。是否要重构基方法?
refactoring.change.signature.visibility.conflict=重构后，该函数在 {0} 中将不可见
revert=还原
run.rustfmt=运行 rustfmt
run.target.build.arguments.comment=在禁用<b>在目标上构建</b>选项的情况下，传递给 <b>cargo build</b> 命令的其他实参
run.target.build.arguments.label=其他构建实参\:
run.target.cargo.executable.path.label=Cargo 可执行文件\:
run.target.cargo.executable.version.label=Cargo 版本\:
run.target.rustc.executable.path.label=Rustc 可执行文件\:
run.target.rustc.executable.version.label=Rustc 版本\:
runs.cargo.command=运行 Cargo 命令
runs.wasm.pack.command=运行 wasm-pack 命令
rust=Rust
rust.1.70.0.stable=Rust 1.70.0 稳定版
rust.cargo.toml=Rust/Cargo.toml
rust.checkin.factory.fmt.commit.anyway.question=仍要提交吗?
rust.checkin.factory.fmt.failed.message=无法运行 rusfmt。
rust.checkin.factory.fmt.header.message=Rustfmt 无法格式化 {0}
rust.checkin.factory.fmt.rustfmt.not.installed.message=Rustfmt 未安装。
rust.code.vision.implementation.hint={0,choice, 1\#1 个实现|2\#{0,number} 个实现}
rust.code.vision.overrides.hint={0,choice, 1\#1 个重写|2\#{0,number} 个重写}
rust.code.vision.usage.hint={0,choice, 0\#无用法|1\#1 个用法|2\#{0,number} 个用法}
rust.compiler=Rust 编译器
rust.consoles=Rust 控制台
rust.debugger.renderers.bundled.item=捆绑呈现器
rust.debugger.renderers.compiler.item=Rust 编译器的呈现器
rust.debugger.renderers.none.item=没有呈现器
rust.external.linter=Rust 外部 linter
rust.external.linter.cargo.check.item=Cargo Check
rust.external.linter.clippy.item=Clippy
rust.file=Rust 文件
rust.module=Rust 模块
rust.repl=Rust REPL
rustc.bootstrap.warning=为了支持 {0}，IDE 使用 {2} 环境变量运行 {1}，这很少会导致构建/测试结果不一致。{3} 您可以通过{4}避免潜在的不一致。
same.as.d.but.space.padded.8=( 8)与 %d 相同，但用空格填充
same.as.h.but.space.padded.same.as.h=( 0)与 %H 相同，但用空格填充。与 %_H 相同
same.as.i.but.space.padded.same.as.i=(12)与 %I 相同，但用空格填充。与 %_I 相同
same.as.u.but.uses.the.week.number.in.iso.8601.week.date.01.53=(27)与 %U 相同，但使用 ISO 8601 周日期中的周数字(01?53)
same.as.u.but.week.1.starts.with.the.first.monday.in.that.year.instead=(27)与 %U 相同，但第 1 周从该年的第一个星期一开始
same.as.y.but.uses.the.year.number.in.iso.8601.week.date=(01)与 %y 相同，但使用 ISO 8601 周日期中的年份数字
same.as.y.but.uses.the.year.number.in.iso.8601.week.date.2001=(2001)与 %Y 相同，但使用 ISO 8601 周日期中的年份数字
same.as.z.but.with.a.colon=与 %z 相同，但带有冒号
second.number.00.60.zero.padded.to.2.digits=(00-60)秒数字，在前面填充零，变成 2 位数
separator.items.to.move=要移动的条目
separator.members.to.form.trait=形成特征的成员
settings.rust.auto.import.exclude.comment=像在 <code>use</code> 声明中一样指定每个路径。如果要对路径中包含给定前缀的所有条目禁用自动导入，请将 <code>\:\:*</code> 添加到路径。排除特征时，指定仅对特征方法还是同时对特征名称禁用自动导入。请注意，<code>use</code> 声明会覆盖这些设置。
settings.rust.auto.import.exclude.label=从自动导入和补全中排除\:
settings.rust.auto.import.on.completion=补全时导入作用域外的条目
settings.rust.auto.import.on.paste=粘贴时插入 import
settings.rust.auto.import.show.popup=显示 import 弹出窗口
settings.rust.auto.import.title=Rust
settings.rust.cargo.auto.update.project.label=Cargo.toml 更改时自动更新项目
settings.rust.cargo.compile.all.targets.comment=将 <b>--target-all</b> 选项传递至 Cargo <b>build</b>/<b>check</b> 命令
settings.rust.cargo.compile.all.targets.label=尽可能编译所有项目目标
settings.rust.cargo.moved.label=Cargo 设置已移动到“构建、执行、部署 | 构建工具 | Cargo”
settings.rust.cargo.name=Cargo
settings.rust.cargo.offline.mode.comment=将 <b>--offline</b> 选项传递至 Cargo 以避免网络请求
settings.rust.cargo.offline.mode.label=脱机模式
settings.rust.cargo.show.first.error.label=构建失败后自动在编辑器中显示第一个错误
settings.rust.code.style.align.return.type=将返回值类型与函数形参对齐
settings.rust.code.style.align.where.clause=将 `where` 子句与函数形参对齐
settings.rust.code.style.align.where.clause.bounds=对齐 'where' 子句边界
settings.rust.code.style.around.associated.type.bindings=关联类型绑定周围
settings.rust.code.style.between.declarations=声明之间\:
settings.rust.code.style.indent.where.clause=缩进 'where' 子句
settings.rust.code.style.match.expressions.in.one.line=在一行中匹配表达式
settings.rust.code.style.name=Rust
settings.rust.code.style.punctuation=标点
settings.rust.color.associated.function.call=函数//关联函数调用
settings.rust.color.associated.function.declaration=函数//关联函数声明
settings.rust.color.attribute=特性
settings.rust.color.char=文字//字符
settings.rust.color.conditionally.disabled.code=有条件禁用的代码
settings.rust.color.const.parameter=形参//const 形参
settings.rust.color.constant=变量//常量
settings.rust.color.crate=类型//Crate
settings.rust.color.enum=类型//枚举
settings.rust.color.enum.variant=类型//枚举变体
settings.rust.color.field=变量//字段
settings.rust.color.format.parameter=文字//字符串//格式形参
settings.rust.color.format.specifier=文字//字符串//格式形参内的格式说明符
settings.rust.color.function.call=函数//函数调用
settings.rust.color.function.declaration=函数//函数声明
settings.rust.color.generated.items=由宏生成的条目
settings.rust.color.invalid.escape.sequence=文字//字符串//转义序列//无效
settings.rust.color.keyword=关键字//关键字
settings.rust.color.keyword.unsafe=关键字//unsafe
settings.rust.color.lifetime=形参//生命周期
settings.rust.color.macro=函数//宏
settings.rust.color.method.call=函数//方法调用
settings.rust.color.method.declaration=函数//方法声明
settings.rust.color.module=类型//模块
settings.rust.color.mutable.binding=变量//可变绑定
settings.rust.color.mutable.parameter=形参//可变形参
settings.rust.color.number=文字//数字
settings.rust.color.operation.sign=大括号和运算符//运算符号
settings.rust.color.parameter=形参//形参
settings.rust.color.primitive=类型//基元
settings.rust.color.question.mark=大括号和运算符/? 运算符
settings.rust.color.rustdoc.bold=Rustdoc//粗体文本
settings.rust.color.rustdoc.code=Rustdoc//代码
settings.rust.color.rustdoc.comment=Rustdoc//注释
settings.rust.color.rustdoc.heading=Rustdoc//标题
settings.rust.color.rustdoc.italic=Rustdoc//斜体文本
settings.rust.color.rustdoc.link=Rustdoc //链接
settings.rust.color.scheme.title=Rust
settings.rust.color.self.parameter=形参//Self 形参
settings.rust.color.static=变量//static
settings.rust.color.static.mutable=变量//可变 static
settings.rust.color.string=文字//字符串//字符串
settings.rust.color.struct=类型//结构
settings.rust.color.trait=类型//特征
settings.rust.color.type.alias=类型//类型别名
settings.rust.color.type.parameter=形参//类型形参
settings.rust.color.union=类型//联合
settings.rust.color.unsafe.code=unsafe 代码
settings.rust.color.valid.escape.sequence=文字//字符串//转义序列//有效
settings.rust.color.variables.default=变量//默认值
settings.rust.completion.suggest.out.of.scope.items=建议作用域外的条目
settings.rust.completion.title=Rust
settings.rust.external.linters.additional.arguments.comment=传递至 <b>cargo check</b> 或 <b>cargo clippy</b> 命令的其他实参
settings.rust.external.linters.additional.arguments.label=其他实参\:
settings.rust.external.linters.channel.label=通道\:
settings.rust.external.linters.name=外部 Linter
settings.rust.external.linters.on.the.fly.comment=添加基于外部 linter 结果的代码高亮显示。可能会影响 IDE 性能
settings.rust.external.linters.on.the.fly.label=运行外部 linter 以即时分析代码
settings.rust.external.linters.tool.comment=用于其他代码分析的外部工具
settings.rust.external.linters.tool.label=外部工具\:
settings.rust.folding.one.line.methods.checkbox=一行方法
settings.rust.folding.title=Rust
settings.rust.inlay.hints.for=显示以下项的提示\:
settings.rust.inlay.hints.for.closures=闭包
settings.rust.inlay.hints.for.exclusive.range.expressions=独占范围表达式
settings.rust.inlay.hints.for.exclusive.range.patterns=独占范围模式
settings.rust.inlay.hints.for.iterators=迭代器作为 `impl Iterator<...>`
settings.rust.inlay.hints.for.loop.variables=循环变量
settings.rust.inlay.hints.for.obvious.types=明显类型
settings.rust.inlay.hints.for.same.consecutive.types=相同的连续类型
settings.rust.inlay.hints.for.type.placeholders=类型占位符
settings.rust.inlay.hints.for.variables=变量
settings.rust.inlay.hints.title.method.chains=方法链
settings.rust.inlay.hints.title.types=类型
settings.rust.inlay.hints.title.values=值
settings.rust.inlay.parameter.hints.only.smart=仅智能提示
settings.rust.rustfmt.additional.arguments.comment=传递给 <b>rustfmt</b> 或 <b>cargo fmt</b> 命令的其他实参
settings.rust.rustfmt.additional.arguments.label=其他实参\:
settings.rust.rustfmt.builtin.formatter.label=使用 Rustfmt 代替内置格式化程序
settings.rust.rustfmt.channel.label=通道\:
settings.rust.rustfmt.name=Rustfmt
settings.rust.rustfmt.run.on.save.label=保存时运行 rustfmt
settings.rust.toolchain.download.rustup.dialog.title=正在下载 Rust 标准库
settings.rust.toolchain.download.rustup.link=通过 Rustup 下载
settings.rust.toolchain.download.rustup.progress.text=正在使用 Rustup 安装…
settings.rust.toolchain.expand.macros.checkbox=展开宏
settings.rust.toolchain.expand.macros.comment=允许插件处理宏调用以提取名称解析和类型推断的信息
settings.rust.toolchain.inject.rust.in.doc.comments.checkbox=将 Rust 语言注入文档注释
settings.rust.toolchain.invalid.toolchain.error=无效的工具链位置\: 在 {0} 中找不到 Cargo
settings.rust.toolchain.location.label=工具链位置\:
settings.rust.toolchain.name=Rust
settings.rust.toolchain.not.applicable.version.text=不适用
settings.rust.toolchain.select.standard.library.dialog.title=选择标准库源的位置
settings.rust.toolchain.standard.library.label=标准库\:
settings.rust.toolchain.version.label=工具链版本\:
signature=签名\:
similar.to.3f.but.without.the.leading.dot.026=(026)类似于 %.3f，但没有前导点
similar.to.6f.but.without.the.leading.dot.026490=(026490)类似于 %.6f，但没有前导点
similar.to.9f.but.without.the.leading.dot.026490000=(026490000)类似于 %.9f，但没有前导点
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.3.026=(.026)类似于 .%f，但为左对齐，且长度固定为 3
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.6.026490=(.026490)类似于 .%f，但为左对齐，且长度固定为 6
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.9.026490000=(.026490000)类似于 .%f，但为左对齐，且长度固定为 9
similar.to.f.but.left.aligned.these.all.consume.the.leading.dot.026490=(.026490)类似于 .%f，但为左对齐。这些均使用前导点
ssr.unsupported.replace.template=暂不支持替换。
ssr.unsupported.search.template=搜索模板包含不受支持的元素。
start.function=\#[start] 函数
status.bar.text.rebuilt.defmap.for.in.ms=在 {1} 毫秒内为 {0} 重建了 DefMap
struct=结构
structs.deriving.default=派生 Default 的结构
structs.with.a.u8.field=具有 u8 字段的结构
structure.view.show.macro.expanded=显示宏展开中的条目
structure.view.sort.visibility=按可见性排序
subslice.patterns=子切片模式
sunday.0.monday.1.saturday.6=(0)星期日 \= 0、星期一 \= 1、…、星期六 \= 6
suspicious.assignment=可疑的赋值
system.notification.text.={0} 个{1}和 {2} 个{3}
system.notification.title.canceled={0}已取消
system.notification.title.failed={0}失败
system.notification.title.finished={0}已完成
tab.title.error.running.console=运行控制台时出错
test=测试
text.conditionally.disabled.code=有条件禁用的代码
the.0.tool.window.was.disabled.1.2=“{0}”工具窗口已禁用。{1}{2}
the.fractional.seconds.in.nanoseconds.since.last.whole.second.026490000=(026490000)自上一整秒以来的小数秒(以纳秒为单位)
the.full.proleptic.gregorian.year.zero.padded.to.4.digits.2021=(2021)完整的外推格里年份，用零填充为 4 位数
the.proleptic.gregorian.year.divided.by.100.zero.padded.to.2.digits.20=(20)外推格里年份除以 100，用零填充为 2 位数
the.proleptic.gregorian.year.modulo.100.zero.padded.to.2.digits.01=(01)外推格里年份以 100 为模，在前面填充零，变成 2 位数
to=到\:
too.many.characters.in.0={0} 中的字符过多
toolchain.version.is.unknown.hardcoded.stdlib.structure.will.be.used=工具链版本未知。将使用硬编码的 stdlib 结构
tooltip.delimiters.should.be=分隔符应为 `(` 和 `)`
tooltip.does.not.have.constant.size.known.at.compile.time=`{0}` 在编译时没有已知的常量大小
tooltip.following.are.possible.correct.uses=以下是可能的正确用法
tooltip.implements=实现
tooltip.in=`{2}` 中的 {0} {1}
tooltip.instead.using.suffixed.literal.1u8.0f32.etc.use.unsuffixed.version.etc=不要使用带后缀的文字(`1u8`、`1.0f32` 等)，而是使用无后缀的版本(`1`、`1.0` 等)
tooltip.must.be.defined.only.once.in.namespace.this=`{0}` 只能在此{2}的 {1} 命名空间中定义一次
tooltip.must.be.form=必须是以下形式
tooltip.overrides=重写
tooltip.project.directory.does.not.exist=项目目录不存在
tooltip.project.needs.update=项目需要更新
tooltip.project.up.to.date=项目处于最新状态
tooltip.target={0}目标 `{1}`
tooltip.this.accepted.in.current.edition.rust.but.hard.error.in.rust=这在当前版本(Rust 2018)中可以接受，但在 Rust 2021 中是一个严重错误\!
tooltip.this.was.previously.accepted.by.compiler.but.being.phased.out.it.will.become.hard.error.in.future.release=这在之前会被编译器接受，但正在逐步淘汰；它将在未来版本中成为严重错误\!
tooltip.trait.not.implemented.for=没有为 `{1}` 实现特征 `{0}`
tooltip.valid.abis=有效的 ABI\: {0}
tooltip.visibility.restriction.with.module.path.should.start.with.in.keyword=模块路径的可见性限制应以 `in` 关键字开头
trait=特征
try.macro.usage=try\! 宏用法
type=类型
type.0=类型\: {0}
type2=类型
unable.to.run.debugger=无法运行调试器
unix.timestamp.the.number.of.seconds.since.1970.01.01.00.00.utc.994518299=(994518299) UNIX 时间戳，自 1970-01-01 00\:00 UTC 以来的秒数
unreachable.patterns=不可到达的模式
unsafe.cstring.pointer=unsafe CString 指针
untrusted.project.notification.execution.error=Cargo 项目不受信任，因此无法执行其任务。
visibility=可见性\:
wasm.pack=wasm-pack
wasm.pack.command.run.configuration=wasm-pack 命令运行配置
wasm.pack.commands=wasm-pack 命令
week.number.starting.with.sunday.00.53.zero.padded.to.2.digits=(28)从星期日开始的周数字，在前面填充零，变成 2 位数
where.clauses.on.associated.types=关联类型上的 where 子句
while.true.loop=While true 循环
year.month.day.format.iso.8601.same.as.y.m.d=(2001-07-08)年-月-日格式(ISO 8601)。与 %Y-%m-%d 相同
yield.syntax=`yield` 语法
