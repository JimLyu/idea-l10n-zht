ambiguous.method.call.no.match=无法解析 ''{1}'' 中的方法 ''{0}''
annotation.annotation.type.expected=应为注解类型
annotation.interface.is.not.used=@interface ''{0}'' 从未使用
annotation.missing.method=找不到 @interface 方法 ''{0}()''
annotation.not.allowed.here=此处不允许注解
annotation.not.applicable=''@{0}'' 不适用于{1}
annotation.on.static.member.qualifying.type.family.name=移动类型注解
annotation.unknown.method=找不到 @interface 方法 ''{0}()''
assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作为标识符
binary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''、''{2}''
cannot.resolve.constructor=无法解析构造函数 ''{0}''
cannot.resolve.method=无法解析方法 ''{0}''
cannot.resolve.package=无法解析软件包 {0}
cannot.resolve.symbol=无法解析符号 ''{0}''
catch.without.try='catch' 没有 'try'
class.is.not.used=类 ''{0}'' 从未使用
class.must.be.abstract=类“{0}”必须声明为抽象，或为实现“{2}”中的抽象方法“{1}”
class.must.implement.method=类 ''{0}'' 必须在 ''{2}'' 中实现 abstract 方法 ''{1}''
constant.expression.required=需要常量表达式
constructor.is.not.used=构造函数 ''{0}'' 从未使用
create.class.action.this.not.valid.java.qualified.name=这不是有效的 Java 限定名称
declaration.not.allowed=此处不允许声明
deconstruction.pattern.requires.record=析构模式只能应用于记录，''{0}'' 不是记录
default.label.must.not.contains.case.keyword=默认 case 的标签只能使用 'default' 关键字，不能使用 'case'
default.label.not.allowed.here=此处不允许使用默认标签\: 'default' 只能用作单个 case 标签或仅与 'null' 配对
deprecated.default.constructor=''{0}'' 中的默认构造函数已弃用
deprecated.since.symbol=''{0}'' 自版本 {1} 起已弃用
deprecated.symbol=''{0}'' 已弃用
duplicate.default.switch.label=默认标签重复
duplicate.switch.label=标签 ''{0}'' 重复
duplicate.unconditional.pattern.label=重复的无条件模式
else.without.if='else' 没有 'if'
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作为标识符
enum.is.not.used=枚举 ''{0}'' 从未使用
error.cannot.infer.pattern.type=无法推断模式类型\: {0}
error.cannot.resolve.class=无法解析类 ''{0}''
error.cannot.resolve.class.or.package=无法解析类或软件包 ''{0}''
exception.is.never.thrown=此方法中从未抛出异常 ''{0}''
expected.boolean.expression=应为布尔表达式
expected.catch.or.finally=应为 'catch' 或 'finally'
expected.comma=应为 ','
expected.expression=应为表达式
expected.identifier=应为标识符
expected.identifier.or.type=应为标识符或类型
expected.lbrace=应为 '{'
expected.lparen=应为 '('
expected.lparen.or.lbracket=应为 '(' 或 '['
expected.parameter=应为形参
expected.rbrace=应为 '}'
expected.rbracket=应为 ']'
expected.rparen=应为 ')'
expected.semicolon=应为 ';'
expected.statement=应为语句
expected.switch.label=应为 'case'、'default' 或 '}'
expected.switch.rule=应为表达式、块或 throw 语句
expected.while=应为 'while'
expression.expected=应为表达式
field.is.not.used=字段 ''{0}'' 从未使用
field.is.not.used.for.reading={0} 字段 ''{1}'' 已被分配，从未被访问
finally.without.try='finally' 没有 'try'
generics.type.argument.cannot.be.of.primitive.type=类型实参不能为基元类型
generics.unchecked.assignment=未检查的赋值\: ''{0}'' 赋值给 ''{1}''
generics.unchecked.call=未检查的方法 ''{0}'' 调用
generics.unchecked.call.to.member.of.raw.type=作为原始类型 ''{1}'' 的成员对 ''{0}'' 的未检查的调用
generics.unchecked.cast=未检查的转换\: ''{0}'' 转换为 ''{1}''
generics.wrong.number.of.type.arguments=类型实参的数量错误\: {0}；要求 {1} 个
identifier.is.not.allowed.here=此处不允许使用标识符
illegal.forward.reference=无法在定义字段 ''{0}'' 之前读取它的值
illegal.type.void=非法类型\: 'void'
inaccessible.type=''{0}'' 无法从此处访问
incompatible.switch.null.type=''{0}'' 无法转换为 ''{1}''
incompatible.types=不兼容的类型。实际为 {1}''，需要 ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style\=''padding\: 0px 16px 8px 4px;color\: {5}''>需要的类型\: </td><td style\=''padding\: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style\=''padding\: 0px 16px 0px 4px;color\: {5}''>提供的类型\: </td><td style\=''padding\: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>原因\: 方法引用不明确\: ''{0}'' 和 ''{1}'' 均匹配
incomplete.project.state.pending.reference=直到项目完全加载后才会解析
inconvertible.type.cast=不可转换的类型；无法将 ''{0}'' 转换为 ''{1}''
incorrect.number.of.nested.patterns=嵌套模式的数量不正确\: 应为 {0}，但实际为 {1}
insufficient.language.level=语言级别 ''{1}'' 不支持 {0}
interface.is.not.used=接口 ''{0}'' 从未使用
invalid.case.label.combination.constants.and.patterns=无效的 case 标签组合\: 一个 case 标签必须包含 case 常量列表或单个 case 模式
invalid.case.label.combination.constants.and.patterns.unnamed=无效的 case 标签组合\: 一个 case 标签必须包含一个 case 常量列表或一个 case 模式列表
invalid.case.label.combination.several.patterns=无效的 case 标签组合\: 一个 case 标签不得包含一个以上的 case 模式
invalid.case.label.combination.several.patterns.unnamed=无效的 case 标签组合\: 只有当模式未声明任何模式变量时，才允许使用多个模式
invalid.default.and.null.order=无效的 case 标签顺序\: 'null' 必须是第一个，'default' 必须是第二个
invalid.statement=语句无效
local.class.is.not.used=本地类 ''{0}'' 从未使用
local.variable.is.never.used=''{0}'' 从未使用变量
local.variable.is.not.assigned=变量 ''{0}'' 从未被赋值
local.variable.is.not.used.for.reading=''{0}'' 已被赋值，从未被访问
marked.for.removal.default.constructor=''{0}'' 中的默认构造函数已弃用并被标记为移除
marked.for.removal.symbol=''{0}'' 已弃用并被标记为移除
marked.for.removal.symbol.since=''{0}'' 自版本 {1} 起已弃用并标记为移除
method.is.not.used=方法 ''{0}'' 从未使用
missing.package.statement=缺少 package 语句\: ''{0}''
missing.package.statement.package.name.invalid=缺少软件包语句，但与文件路径相对应的软件包名称 ''{0}'' 无效
missing.return.statement=缺少 return 语句
module.access.bad.name=软件包 ''{0}'' 在具有无效名称(''{1}'')的模块中声明
module.access.does.not.read=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但模块 ''{2}'' 没有读取它
module.access.from.named=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到模块 ''{2}''
module.access.from.unnamed=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到未命名模块
module.access.not.in.graph=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者不在模块图中
module.access.to.unnamed=软件包 ''{0}'' 在未命名的模块中声明，但模块 ''{1}'' 没有读取它
module.bad.name=模块 ''{0}'' 的名称无效
module.does.not.read=模块 ''{0}'' 无法读取 ''{1}''
module.not.in.graph=模块图中缺少模块 ''{0}''
module.not.on.path=模块不在依赖项中\: {0}
module.open.duplicate.text=转到重复项
module.unwanted.modifier.warn=自 Java 10 起，禁止对 'requires java.base' 使用修饰符
multiple.switch.labels=在标记为 switch 的语句组中，只有在没有声明任何模式变量的情况下，才允许为该语句组指定多个 switch 标签
non.static.symbol.referenced.from.static.context=无法从 static 上下文引用非 static {0} ''{1}'' 
not.a.statement=不是语句
null.label.not.allowed.here=无效的 case 标签组合\: 'null' 只能用作单个 case 标签或仅与 'default' 配对
numeric.overflow.in.expression=表达式中出现数值溢出
overrides.deprecated.method=重写 ''{0}'' 中弃用的方法
overrides.marked.for.removal.method=重写 ''{0}'' 中弃用并标记为移除的方法
package.is.empty=软件包为空\: {0}
package.local.symbol=''{0}'' 在 ''{1}'' 中不为 public。无法从外部软件包访问
package.name.file.path.mismatch=软件包名称 ''{0}'' 与文件路径 ''{1}'' 不对应
package.not.found=找不到软件包\: {0}
parameter.excluding.hierarchy.disable.text=不高亮显示继承方法的形参
parameter.is.not.used=形参 ''{0}'' 从未使用
pattern.variable.is.not.used=模式变量 ''{0}'' 从未使用
private.constructor.is.not.used=private 构造函数 ''{0}'' 从未使用
private.field.is.not.assigned=private 字段 ''{0}'' 从未分配
private.field.is.not.used=private 字段 ''{0}'' 从未使用
private.inner.class.is.not.used=private 内部类 ''{0}'' 从未使用
private.inner.interface.is.not.used=private 内部接口 ''{0}'' 从未使用
private.method.is.not.used=private 方法 ''{0}'' 从未使用
private.symbol=''{0}'' 在 ''{1}'' 中具有 private 访问权限
protected.symbol=''{0}'' 在 ''{1}'' 中具有 protected 访问权限
qualified.enum.constant.in.switch=枚举 switch case 标签必须是枚举常量的非限定名称
qualified.enum.constant.in.switch.remove.fix=移除限定符
record.canonical.constructor=规范构造函数
record.compact.constructor=紧凑构造函数
record.is.not.used=记录 ''{0}'' 从未使用
redundant.semicolon.warn=从 Java 21 开始禁止在 import 语句之间使用冗余的分号
remove.unused.imports.quickfix.text=移除未使用的 import
restricted.identifier=''{0}'' 是受限标识符，不能用于类型声明
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作为类名
return.from.constructor=无法从构造函数返回值
return.from.void.method=无法从结果类型为 void 的方法返回值
return.outside.method=return 位于方法外部
static.member.accessed.via.instance.reference=通过实例引用访问 static 成员 ''{0}.{1}''
suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
suspicious.name.parameter=''{0}'' 可能不应作为形参 ''{1}'' 传递
suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
switch.class.or.array.type.expected=类或数组
switch.constant.expression.required=常量表达式、模式或 null 为必需项
switch.dominance.of.preceding.label=标签由先前的 case 标签 ''{0}'' 支配
switch.expr.empty='switch' 表达式没有任何 case 子句
switch.expr.incomplete='switch' 表达式未涵盖所有可能的输入值
switch.illegal.fall.through.to=到模式的非法直落
switch.invalid.selector.types=不支持 ''{0}'' 的选择器类型
switch.pattern.expected=switch 选择器类型 ''{0}'' 需要模式
switch.statement.empty='switch' 语句没有任何 case 子句
switch.statement.incomplete='switch' 语句未涵盖所有可能的输入值
switch.unconditional.boolean.and.default.exist='switch' 具有所有布尔值和一个 default 标签
switch.unconditional.boolean.and.unconditional.exist='switch' 具有所有布尔值和一个无条件模式
switch.unconditional.pattern.and.default.exist='switch' 同时具有无条件模式和默认标签
text.class.cannot.access=无法访问 {0}
text.class.inherits.abstract.and.default={0} 从类型 {2} 和 {3} 继承 {1} 的抽象和默认值
text.class.inherits.unrelated.defaults={0} 从类型 {2} 继承 {1} 的不相关默认值
text.class.is.not.accessible={0} 在当前上下文中不可访问
type.parameter.is.not.used=类型形参 ''{0}'' 从未使用
unchecked.overriding.incompatible.return.type=未检查的重写\: 返回值类型需要未经检查的转换。实际为 ''{0}''，需要 ''{1}''
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作为标识符
unexpected.token=意外的标记
unexpected.type=意外类型。实际为 ''{1}'' ，需要 ''{0}''
unhandled.exceptions=未处理 {1, choice, 0\#异常|2\#异常}\: {0}
unknown.class=未知类\: ''{0}''
unsafe.cast.in.instanceof=''{0}'' 无法安全转换为 ''{1}''
variable.already.defined=作用域中已定义变量 ''{0}''
variable.not.initialized=变量 ''{0}'' 可能尚未初始化
visibility.access.problem=无法访问 ''{1}'' 中的 ''{0}''
visibility.module.access.problem=对 ''{1}'' 中 ''{0}'' 的访问被 {2} 阻止
yield.unqualified.method.warn=自 Java 14 起的版本中不支持对 'yield' 方法进行非限定调用
