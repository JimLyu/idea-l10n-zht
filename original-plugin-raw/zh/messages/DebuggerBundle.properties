### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=调试进程已分离。

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 行断点
breakpoint.location.constructor.of={0} 的构造函数
breakpoint.location.early.definitions.of={0} 的早期定义
breakpoint.location.line.in.containing.block=包含块中的行
breakpoint.location.line.in.function=函数 {0} 中的行
breakpoint.location.line.in.containing.file=包含文件中的行

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=评估对象需要编译
evaluation.of.class.needs.compilation=评估类需要编译
evaluation.of.trait.needs.compilation=评估特征需要编译
evaluation.of.anonymous.class.needs.compilation=评估匿名类需要编译
evaluation.of.type.alias.needs.compilation=评估类型别名需要编译
evaluation.of.function.definition.needs.compilation=评估函数定义需要编译
evaluation.of.variable.declaration.needs.compilation=评估变量声明需要编译
evaluation.of.lazy.val.definition.needs.compilation=评估 lazy val 定义需要编译
evaluation.of.anonymous.function.needs.compilation=评估匿名函数需要编译
evaluation.of.for.expression.needs.compilation=评估 for 表达式需要编译
evaluation.of.try.statement.needs.compilation=评估 try 语句需要编译
evaluation.of.return.statement.needs.compilation=评估 return 语句需要编译
evaluation.of.match.statement.needs.compilation=评估 match 语句需要编译
evaluation.of.throw.statement.needs.compilation=评估 throw 语句需要编译
evaluation.of.xml.expression.needs.compilation=评估 xml 表达式需要编译
evaluation.of.interpolated.string.needs.compilation=评估插值字符串需要编译
cannot.find.by.name.parameter.with.such.name=找不到具有此名称的传名参数: {0}
evaluation.of.expression.is.not.supported=不支持表达式评估: {0}
evaluation.of.element.is.not.supported=不支持元素评估: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=无法评估导入的引用
cannot.evaluate.local.method=无法评估局部方法
cannot.evaluate.parameter=无法评估形参 {0}
cannot.evaluate.method=无法评估方法 {0}
cannot.evaluate.local.object=无法评估局部对象 {0}
cannot.evaluate.local.variable=无法评估局部变量 {0}
wrong.number.of.arguments=方法 {0} 的实参数量错误
array.instance.is.not.found=无法评估方法 {0}: 找不到数组实例
array.method.not.supported=不支持数组方法
cannot.find.implicit.parameters=找不到要传递的隐式形参
implicit.parameters.from.dependent.objects=依赖对象中的隐式形参不受支持
implicit.conversions.from.dependent.objects=依赖对象中的隐式转换不受支持
method.with.by-name.parameters=无评估法包含传名形参的方法
wrong.number.of.expressions=无法评估实参: 匹配的表达式的数量错误
tupling.not.supported=不支持元组化。请使用元组表达式。
not.used.from.for.statement=无法评估 for 语句中的变量 {0}，因为它没有在主体中使用
cannot.find.pattern=找不到 case 子句的模式
cannot.find.expression.of.match=找不到 match 语句的表达式
invalid.case.clause=无效的 case 子句
assignent.without.expression=无法评估没有表达式的赋值语句
unapply.without.arguments=无法从没有实参的 unapply 提取值
pattern.doesnot.resolves.to.unapply=模式引用 {0} 不会解析为 unapply 或 unapplySeq
pattern.alternatives.cannot.bind.vars=模式替代项不能绑定变量
xml.patterns.not.supported=不支持 xml 模式
kind.of.pattern.not.supported=不支持此类模式: {0}
anon.classes.not.supported=不支持匿名类
new.expression.without.class.reference=无法评估没有类引用的新表达式
new.expression.without.constructor.call=无法评估没有构造函数调用的表达式
new.expression.without.template.parents=无法评估没有模板父项的表达式
could.not.resolve.constructor=无法解析构造函数
if.statement.without.condition=无法评估没有条件的 if 语句
if.statement.without.if.branch=无法评估没有 if 分支的 if 语句
while.statement.without.condition=无法评估没有条件的 while 语句
while.statement.without.body=无法评估没有主体的 while 语句
do.statement.without.condition=无法评估没有条件的 do 语句
do.statement.without.body=无法评估没有主体的 do 语句
method.call.implicitly.converted.qualifier=无法评估包含隐式转换限定符的方法调用: {0}
synchronized.statement.is.not.supported=不支持同步语句
cannot.evaluate.synthetic.method=无法评估合成方法: {0}
by.name.parameter.expected=应为传名参数
update.method.is.not.supported=不支持更新方法
variable.definition.needs.right.hand.side=变量定义需要在右侧: {0}
value.definition.needs.right.hand.side=值定义需要在右侧: {0}
new.synthetic.instantiation={0} ''{1}'' 为 abstract；无法实例化
missing.type.argument.synthetic.method=在没有显式类型实参的情况下调用了 {0}
constructor.param.inaccessible.outside.of.constructor=在类构造函数外部无法访问构造函数形参 ''{0}''
array.constructor.unspecified.parameters=未指定的值形参: _length: Int
array.constructor.too.many.arguments=构造函数数组(Int)的实参过多

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=无法编译:\n{0}
compilation.failed=编译失败

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=无法将类型 ''{0}'' 的值转换为类型 ''{1}''

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=文字类型 ({0} : {1}) 不是类类型

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1} 不能在运行时类型测试中使用
error.value.isinstanceof.reference=无法测试类型 {0} 的值是否为类型 {1} 的引用
error.isinstanceof.structural.type=未选中结构类型的运行时类型测试

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=无法解析值类 {0} 的主构造函数

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=无法为 {0} 执行装箱转换

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=无法编译生成的类
error.during.generated.code.invocation=生成代码调用时出错:\n {0}
error.creating.evaluation.class.loader=创建评估类加载器时出错:\n {0}
error.during.classes.definition=类定义时出错:\n {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=未知的文字类型
literal.has.null.value=文字 {0} 有 null 值

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=找不到 {0} 的适用构造函数
cannot.invoke.abstract.interface.method.name=无法调用抽象接口方法 {0}
method.methodname.cannot.be.invoked.on.array=无法在数组上调用方法 {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=外部 `this` 不可用

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=找不到编译模块
could.not.evaluate.due.to.a.change.in.a.source.file=由于源文件中的变更而无法评估
could.not.compile.local.class.in.this.context=无法在此上下文中编译本地类

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=在调试器中友好地显示 Scala 集合
dont.show.runtime.refs=不在调试器中显示运行时引用
show.variables.from.outer.scopes.in.variables.view=在变量视图中显示外部范围中的变量

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=不单步执行具体的 Scala 类(&I)

### org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala 对象

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala 集合

### org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala 运行时引用

### org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=找不到位图字段 {0}
could.not.find.accessor.method=找不到字段 {0} 的访问器方法
initialize.lazy.val=初始化
lazy.val.not.initialized=<not initialized>
collection.element.descriptors.evaluation.not.supported="不支持集合元素描述符的评估"
