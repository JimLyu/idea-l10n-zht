### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=偵錯程序已分離。

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 行中斷點
breakpoint.location.constructor.of={0} 的建構函式
breakpoint.location.early.definitions.of={0} 的早期定義
breakpoint.location.line.in.containing.block=包含塊中的行
breakpoint.location.line.in.function=函式 {0} 中的行
breakpoint.location.line.in.containing.file=包含檔案中的行

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=評估物件需要編譯
evaluation.of.class.needs.compilation=評估類別需要編譯
evaluation.of.trait.needs.compilation=評估特徵需要編譯
evaluation.of.anonymous.class.needs.compilation=評估匿名類別需要編譯
evaluation.of.type.alias.needs.compilation=評估類型別名需要編譯
evaluation.of.function.definition.needs.compilation=評估函式定義需要編譯
evaluation.of.variable.declaration.needs.compilation=評估變數宣告需要編譯
evaluation.of.lazy.val.definition.needs.compilation=評估 lazy val 定義需要編譯
evaluation.of.anonymous.function.needs.compilation=評估匿名函式需要編譯
evaluation.of.for.expression.needs.compilation=評估 for 表達式需要編譯
evaluation.of.try.statement.needs.compilation=評估 try 語句需要編譯
evaluation.of.return.statement.needs.compilation=評估 return 語句需要編譯
evaluation.of.match.statement.needs.compilation=評估 match 語句需要編譯
evaluation.of.throw.statement.needs.compilation=評估 throw 語句需要編譯
evaluation.of.xml.expression.needs.compilation=評估 xml 表達式需要編譯
evaluation.of.interpolated.string.needs.compilation=評估插值字串需要編譯
cannot.find.by.name.parameter.with.such.name=找不到具有此名稱的傳名參數: {0}
evaluation.of.expression.is.not.supported=不支持表達式評估: {0}
evaluation.of.element.is.not.supported=不支持元素評估: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=無法評估匯入的參照
cannot.evaluate.local.method=無法評估區域方法
cannot.evaluate.parameter=無法評估參數 {0}
cannot.evaluate.method=無法評估方法 {0}
cannot.evaluate.local.object=無法評估區域物件 {0}
cannot.evaluate.local.variable=無法評估區域變數 {0}
wrong.number.of.arguments=方法 {0} 的實參數量錯誤
array.instance.is.not.found=無法評估方法 {0}: 找不到陣列實例
array.method.not.supported=不支持陣列方法
cannot.find.implicit.parameters=找不到要傳遞的隱式參數
implicit.parameters.from.dependent.objects=相依物件中的隱式參數不受支援
implicit.conversions.from.dependent.objects=相依物件中的隱式轉換不受支援
method.with.by-name.parameters=無評估法包含傳名參數的方法
wrong.number.of.expressions=無法評估實參: 符合的表達式的數量錯誤
tupling.not.supported=不支持元組化。請使用元組表達式。
not.used.from.for.statement=無法評估 for 語句中的變數 {0}，因為它沒有在主體中使用
cannot.find.pattern=找不到 case 子句的模式
cannot.find.expression.of.match=找不到 match 語句的表達式
invalid.case.clause=無效的 case 子句
assignent.without.expression=無法評估沒有表達式的賦值語句
unapply.without.arguments=無法從沒有實參的 unapply 提取值
pattern.doesnot.resolves.to.unapply=模式參照 {0} 不會解析為 unapply 或 unapplySeq
pattern.alternatives.cannot.bind.vars=模式替代項不能綁定變數
xml.patterns.not.supported=不支持 xml 模式
kind.of.pattern.not.supported=不支持此類別模式: {0}
anon.classes.not.supported=不支持匿名類別
new.expression.without.class.reference=無法評估沒有類別參照的新表達式
new.expression.without.constructor.call=無法評估沒有建構函式呼叫的表達式
new.expression.without.template.parents=無法評估沒有模板父項的表達式
could.not.resolve.constructor=無法解析建構函式
if.statement.without.condition=無法評估沒有條件的 if 語句
if.statement.without.if.branch=無法評估沒有 if 分支的 if 語句
while.statement.without.condition=無法評估沒有條件的 while 語句
while.statement.without.body=無法評估沒有主體的 while 語句
do.statement.without.condition=無法評估沒有條件的 do 語句
do.statement.without.body=無法評估沒有主體的 do 語句
method.call.implicitly.converted.qualifier=無法評估包含隱式轉換限定符的方法呼叫: {0}
synchronized.statement.is.not.supported=不支持同步語句
cannot.evaluate.synthetic.method=無法評估合成方法: {0}
by.name.parameter.expected=應為傳名參數
update.method.is.not.supported=不支持更新方法
variable.definition.needs.right.hand.side=變數定義需要在右側: {0}
value.definition.needs.right.hand.side=值定義需要在右側: {0}
new.synthetic.instantiation={0} ''{1}'' 為 abstract；無法實例化
missing.type.argument.synthetic.method=在沒有顯式類型實參的情況下呼叫了 {0}
constructor.param.inaccessible.outside.of.constructor=在類別建構函式外部無法存取建構函式參數 ''{0}''
array.constructor.unspecified.parameters=未指定的值參數: _length: Int
array.constructor.too.many.arguments=建構函式陣列(Int)的實參過多

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=無法編譯:\n{0}
compilation.failed=編譯失敗

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=無法將類型 ''{0}'' 的值轉換為類型 ''{1}''

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=文字類型 ({0} : {1}) 不是類別類型

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1} 不能在執行時類型測試中使用
error.value.isinstanceof.reference=無法測試類型 {0} 的值是否為類型 {1} 的參照
error.isinstanceof.structural.type=未選中結構類型的執行時類型測試

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=無法解析值類別 {0} 的主建構函式

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=無法為 {0} 執行裝箱轉換

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=無法編譯生成的類別
error.during.generated.code.invocation=生成程式碼調用時出錯:\n {0}
error.creating.evaluation.class.loader=建立評估類別載入器時出錯:\n {0}
error.during.classes.definition=類別定義時出錯:\n {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=未知的文字類型
literal.has.null.value=文字 {0} 有 null 值

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=找不到 {0} 的適用建構函式
cannot.invoke.abstract.interface.method.name=無法呼叫抽象接口方法 {0}
method.methodname.cannot.be.invoked.on.array=無法在陣列上呼叫方法 {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=外部 `this` 不可用

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=找不到編譯模組
could.not.evaluate.due.to.a.change.in.a.source.file=由於原始檔中的變更而無法評估
could.not.compile.local.class.in.this.context=無法在此上下文中編譯本地類別

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=在偵錯器中友好地顯示 Scala 集合
dont.show.runtime.refs=不在偵錯器中顯示執行時參照
show.variables.from.outer.scopes.in.variables.view=在變數檢視中顯示外部範圍中的變數

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=不單步執行具體的 Scala 類別(&I)

### org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala 物件

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala 集合

### org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala 執行時參照

### org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=找不到位圖欄位 {0}
could.not.find.accessor.method=找不到欄位 {0} 的存取器方法
initialize.lazy.val=初始化
lazy.val.not.initialized=<not initialized>
collection.element.descriptors.evaluation.not.supported="不支持集合元素描述符的評估"
