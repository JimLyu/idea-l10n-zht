ambiguous.method.call.no.match=無法解析 ''{1}'' 中的方法 ''{0}''
annotation.annotation.type.expected=應為註解類型
annotation.interface.is.not.used=@interface ''{0}'' 從未使用
annotation.missing.method=找不到 @interface 方法 ''{0}()''
annotation.not.allowed.here=此處不允許註解
annotation.not.applicable=''@{0}'' 不適用於{1}
annotation.on.static.member.qualifying.type.family.name=移動類型註解
annotation.unknown.method=找不到 @interface 方法 ''{0}()''
assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作為關鍵字
binary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''、''{2}''
cannot.resolve.constructor=無法解析建構函式 ''{0}''
cannot.resolve.method=無法解析方法 ''{0}''
cannot.resolve.package=無法解析軟體套件 {0}
cannot.resolve.symbol=無法解析符號 ''{0}''
catch.without.try='catch' 沒有 'try'
class.is.not.used=類別 ''{0}'' 從未使用
class.must.be.abstract=類別“{0}”必須宣告為抽象，或為實作“{2}”中的抽象方法“{1}”
class.must.implement.method=類別 ''{0}'' 必須在 ''{2}'' 中實作 abstract 方法 ''{1}''
constant.expression.required=需要常數表達式
constructor.is.not.used=建構函式 ''{0}'' 從未使用
create.class.action.this.not.valid.java.qualified.name=這不是有效的 Java 限定名稱
declaration.not.allowed=此處不允許宣告
deconstruction.pattern.requires.record=解構模式只能應用於記錄，''{0}'' 不是記錄
default.label.must.not.contains.case.keyword=預設 case 的標籤只能使用 'default' 關鍵字，不能使用 'case'
default.label.not.allowed.here=此處不允許使用預設標籤\: 'default' 只能用作單個 case 標籤或僅與 'null' 配對
deprecated.default.constructor=''{0}'' 中的預設建構函式已棄用
deprecated.since.symbol=''{0}'' 自版本 {1} 起已棄用
deprecated.symbol=''{0}'' 已棄用
duplicate.default.switch.label=預設標籤重複
duplicate.switch.label=標籤 ''{0}'' 重複
duplicate.unconditional.pattern.label=重複的無條件模式
else.without.if='else' 沒有 'if'
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作為關鍵字
enum.is.not.used=枚舉 ''{0}'' 從未使用
error.cannot.infer.pattern.type=無法推斷模式類型\: {0}
error.cannot.resolve.class=無法解析類別 ''{0}''
error.cannot.resolve.class.or.package=無法解析類別或軟體套件 ''{0}''
exception.is.never.thrown=此方法中從未拋出異常 ''{0}''
expected.boolean.expression=應為布爾表達式
expected.catch.or.finally=應為 'catch' 或 'finally'
expected.comma=應為 ','
expected.expression=應為表達式
expected.identifier=應為關鍵字
expected.identifier.or.type=應為關鍵字或類型
expected.lbrace=應為 '{'
expected.lparen=應為 '('
expected.lparen.or.lbracket=應為 '(' 或 '['
expected.parameter=應為參數
expected.rbrace=應為 '}'
expected.rbracket=應為 ']'
expected.rparen=應為 ')'
expected.semicolon=應為 ';'
expected.statement=應為語句
expected.switch.label=應為 'case'、'default' 或 '}'
expected.switch.rule=應為表達式、塊或 throw 語句
expected.while=應為 'while'
expression.expected=應為表達式
field.is.not.used=欄位 ''{0}'' 從未使用
field.is.not.used.for.reading={0} 欄位 ''{1}'' 已被分配，從未被存取
finally.without.try='finally' 沒有 'try'
generics.type.argument.cannot.be.of.primitive.type=類型實參不能為基元類型
generics.unchecked.assignment=未檢查的賦值\: ''{0}'' 賦值給 ''{1}''
generics.unchecked.call=未檢查的方法 ''{0}'' 呼叫
generics.unchecked.call.to.member.of.raw.type=作為原始類型 ''{1}'' 的成員對 ''{0}'' 的未檢查的呼叫
generics.unchecked.cast=未檢查的轉換\: ''{0}'' 轉換為 ''{1}''
generics.wrong.number.of.type.arguments=類型實參的數量錯誤\: {0}；要求 {1} 個
identifier.is.not.allowed.here=此處不允許使用關鍵字
illegal.forward.reference=無法在定義欄位 ''{0}'' 之前讀取它的值
illegal.type.void=非法類型\: 'void'
inaccessible.type=''{0}'' 無法從此處存取
incompatible.switch.null.type=''{0}'' 無法轉換為 ''{1}''
incompatible.types=不相容的類型。實際為 {1}''，需要 ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style\=''padding\: 0px 16px 8px 4px;color\: {5}''>需要的類型\: </td><td style\=''padding\: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style\=''padding\: 0px 16px 0px 4px;color\: {5}''>提供的類型\: </td><td style\=''padding\: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>原因\: 方法參照不明確\: ''{0}'' 和 ''{1}'' 均符合
incomplete.project.state.pending.reference=直到專案完全載入後才會解析
inconvertible.type.cast=不可轉換的類型；無法將 ''{0}'' 轉換為 ''{1}''
incorrect.number.of.nested.patterns=嵌套模式的數量不正確\: 應為 {0}，但實際為 {1}
insufficient.language.level=語言級別 ''{1}'' 不支持 {0}
interface.is.not.used=接口 ''{0}'' 從未使用
invalid.case.label.combination.constants.and.patterns=無效的 case 標籤組合\: 一個 case 標籤必須包含 case 常數列表或單個 case 模式
invalid.case.label.combination.constants.and.patterns.unnamed=無效的 case 標籤組合\: 一個 case 標籤必須包含一個 case 常數列表或一個 case 模式列表
invalid.case.label.combination.several.patterns=無效的 case 標籤組合\: 一個 case 標籤不得包含一個以上的 case 模式
invalid.case.label.combination.several.patterns.unnamed=無效的 case 標籤組合\: 只有當模式未宣告任何模式變數時，才允許使用多個模式
invalid.default.and.null.order=無效的 case 標籤順序\: 'null' 必須是第一個，'default' 必須是第二個
invalid.statement=語句無效
local.class.is.not.used=本地類別 ''{0}'' 從未使用
local.variable.is.never.used=''{0}'' 從未使用變數
local.variable.is.not.assigned=變數 ''{0}'' 從未被賦值
local.variable.is.not.used.for.reading=''{0}'' 已被賦值，從未被存取
marked.for.removal.default.constructor=''{0}'' 中的預設建構函式已棄用並被標記為移除
marked.for.removal.symbol=''{0}'' 已棄用並被標記為移除
marked.for.removal.symbol.since=''{0}'' 自版本 {1} 起已棄用並標記為移除
method.is.not.used=方法 ''{0}'' 從未使用
missing.package.statement=缺少 package 語句\: ''{0}''
missing.package.statement.package.name.invalid=缺少軟體套件語句，但與檔案路徑相對應的軟體套件名稱 ''{0}'' 無效
missing.return.statement=缺少 return 語句
module.access.bad.name=軟體套件 ''{0}'' 在具有無效名稱(''{1}'')的模組中宣告
module.access.does.not.read=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但模組 ''{2}'' 沒有讀取它
module.access.from.named=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到模組 ''{2}''
module.access.from.unnamed=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到未命名模組
module.access.not.in.graph=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者不在模組圖中
module.access.to.unnamed=軟體套件 ''{0}'' 在未命名的模組中宣告，但模組 ''{1}'' 沒有讀取它
module.bad.name=模組 ''{0}'' 的名稱無效
module.does.not.read=模組 ''{0}'' 無法讀取 ''{1}''
module.not.in.graph=模組圖中缺少模組 ''{0}''
module.not.on.path=模組不在相依項中\: {0}
module.open.duplicate.text=轉到重複項
module.unwanted.modifier.warn=自 Java 10 起，禁止對 'requires java.base' 使用修飾符
multiple.switch.labels=在標記為 switch 的語句組中，只有在沒有宣告任何模式變數的情況下，才允許為該語句組指定多個 switch 標籤
non.static.symbol.referenced.from.static.context=無法從 static 上下文參照非 static {0} ''{1}'' 
not.a.statement=不是語句
null.label.not.allowed.here=無效的 case 標籤組合\: 'null' 只能用作單個 case 標籤或僅與 'default' 配對
numeric.overflow.in.expression=表達式中出現數值溢出
overrides.deprecated.method=覆寫 ''{0}'' 中棄用的方法
overrides.marked.for.removal.method=覆寫 ''{0}'' 中棄用並標記為移除的方法
package.is.empty=軟體套件為空\: {0}
package.local.symbol=''{0}'' 在 ''{1}'' 中不為 public。無法從外部軟體套件存取
package.name.file.path.mismatch=軟體套件名稱 ''{0}'' 與檔案路徑 ''{1}'' 不對應
package.not.found=找不到軟體套件\: {0}
parameter.excluding.hierarchy.disable.text=不醒目提示繼承方法的參數
parameter.is.not.used=參數 ''{0}'' 從未使用
pattern.variable.is.not.used=模式變數 ''{0}'' 從未使用
private.constructor.is.not.used=private 建構函式 ''{0}'' 從未使用
private.field.is.not.assigned=private 欄位 ''{0}'' 從未分配
private.field.is.not.used=private 欄位 ''{0}'' 從未使用
private.inner.class.is.not.used=private 內部類別 ''{0}'' 從未使用
private.inner.interface.is.not.used=private 內部接口 ''{0}'' 從未使用
private.method.is.not.used=private 方法 ''{0}'' 從未使用
private.symbol=''{0}'' 在 ''{1}'' 中具有 private 存取權限
protected.symbol=''{0}'' 在 ''{1}'' 中具有 protected 存取權限
qualified.enum.constant.in.switch=枚舉 switch case 標籤必須是枚舉常數的非限定名稱
qualified.enum.constant.in.switch.remove.fix=移除限定符
record.canonical.constructor=規範建構函式
record.compact.constructor=緊湊建構函式
record.is.not.used=記錄 ''{0}'' 從未使用
redundant.semicolon.warn=從 Java 21 開始禁止在 import 語句之間使用冗餘的分號
remove.unused.imports.quickfix.text=移除未使用的 import
restricted.identifier=''{0}'' 是受限關鍵字，不能用於類型宣告
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作為類別名
return.from.constructor=無法從建構函式返回值
return.from.void.method=無法從結果類型為 void 的方法返回值
return.outside.method=return 位於方法外部
static.member.accessed.via.instance.reference=通過實例參照存取 static 成員 ''{0}.{1}''
suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
switch.class.or.array.type.expected=類別或陣列
switch.constant.expression.required=常數表達式、模式或 null 為必需項
switch.dominance.of.preceding.label=標籤由先前的 case 標籤 ''{0}'' 支配
switch.expr.empty='switch' 表達式沒有任何 case 子句
switch.expr.incomplete='switch' 表達式未涵蓋所有可能的輸入值
switch.illegal.fall.through.to=到模式的非法直落
switch.invalid.selector.types=不支持 ''{0}'' 的選擇器類型
switch.pattern.expected=switch 選擇器類型 ''{0}'' 需要模式
switch.statement.empty='switch' 語句沒有任何 case 子句
switch.statement.incomplete='switch' 語句未涵蓋所有可能的輸入值
switch.unconditional.boolean.and.default.exist='switch' 具有所有布林值和一個 default 標籤
switch.unconditional.boolean.and.unconditional.exist='switch' 具有所有布林值和一個無條件模式
switch.unconditional.pattern.and.default.exist='switch' 同時具有無條件模式和預設標籤
text.class.cannot.access=無法存取 {0}
text.class.inherits.abstract.and.default={0} 從類型 {2} 和 {3} 繼承 {1} 的抽象和預設值
text.class.inherits.unrelated.defaults={0} 從類型 {2} 繼承 {1} 的不相關預設值
text.class.is.not.accessible={0} 在當前上下文中不可存取
type.parameter.is.not.used=類型參數 ''{0}'' 從未使用
unchecked.overriding.incompatible.return.type=未檢查的覆寫\: 返回值類型需要未經檢查的轉換。實際為 ''{0}''，需要 ''{1}''
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作為關鍵字
unexpected.token=意外的標記
unexpected.type=意外類型。實際為 ''{1}'' ，需要 ''{0}''
unhandled.exceptions=未處理 {1, choice, 0\#異常|2\#異常}\: {0}
unknown.class=未知類別\: ''{0}''
unsafe.cast.in.instanceof=''{0}'' 無法安全轉換為 ''{1}''
variable.already.defined=作用域中已定義變數 ''{0}''
variable.not.initialized=變數 ''{0}'' 可能尚未初始化
visibility.access.problem=無法存取 ''{1}'' 中的 ''{0}''
visibility.module.access.problem=對 ''{1}'' 中 ''{0}'' 的存取被 {2} 阻止
yield.unqualified.method.warn=自 Java 14 起的版本中不支持對 'yield' 方法進行非限定呼叫
