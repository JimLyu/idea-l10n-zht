jvm.inspections.group.name=JVM 語言

jvm.inspections.unstable.api.usage.display.name=不穩定的 API 用法
jvm.inspections.unstable.api.usage.annotations.list=不穩定的 API 註解:
jvm.inspections.unstable.api.usage.ignore.inside.imports=在匯入內忽略
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此專案中宣告的 API
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=覆寫方法 ''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=覆寫方法 ''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不穩定，因為其簽名參照了標記為 @{3} 的不穩定{1} ''{2}''

jvm.inspections.scheduled.for.removal.future.version=未來版本
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=覆寫方法 ''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=覆寫方法 ''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已計劃移除，因為其簽名參照了已計劃從 {3} 中移除的{1} ''{2}''

jvm.inspections.unstable.type.used.in.signature.display.name=簽名中使用了不穩定的類型
jvm.inspections.unstable.type.used.in.class.signature.description=類別必須使用 ''@{0}'' 註解標記，因為其宣告參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必須使用 ''@{0}'' 註解標記，因為其簽名參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=欄位必須使用 ''@{0}'' 註解標記，因為其類型參照了不穩定的類型 ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已計劃移除的 API 上缺少 '@Deprecated' 註解
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已計劃移除的 API 也必須使用 '@Deprecated' 註解標記
jvm.inspections.must.already.be.removed.api.display.name=API 必須已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必須已在版本 {0} 中移除，但當前版本為 {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API 必須在當前版本 {0} 中移除
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞呼叫
jvm.inspections.blocking.method.annotation.blocking=阻塞註解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=新增阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=新增非阻塞註解
jvm.inspections.blocking.method.annotation.configure.empty.text=未新增註解。

jvm.inspections.api.no.extension.display.name=不應擴展類別、接口或方法
jvm.inspections.api.no.extension.class.description=不得擴展類別 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得實作接口 ''{0}''
jvm.inspections.api.no.extension.interface.extend.description=不得擴展接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得覆寫方法 ''{0}''
jvm.inspections.api.override.only.display.name=方法只能覆寫
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能覆寫

jvm.inspections.dependency.display.name=非法的軟體套件相依項
jvm.inspections.dependency.edit.rules.text=編輯相依關係規則 "{0} "
jvm.inspections.dependency.edit.rules.family=編輯相依關係規則
jvm.inspections.dependency.configure.button.text=設定相依關係規則
jvm.inspections.dependency.violator.problem.descriptor=違反相依關係規則 ''{0}.''


jvm.inspections.testonly.display.name=生產程式碼中的純測試用法
jvm.inspections.testonly.class.reference=在生產程式碼中參照純測試類別
jvm.inspections.testonly.field.reference=在生產程式碼中參照純測試欄位
jvm.inspections.testonly.method.call=在生產程式碼中呼叫純測試方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 對 @TestOnly 程式碼意義不大

jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.{0}()</code> #loc
can.t.build.uast.tree.for.file=無法為檔案建置 UAST 樹
title.uast=UAST
current.version=當前版本:
dialog.title.choose.annotation=選擇 {0}
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.nested.class.descriptor=使用 ''@Nested'' 註解的類別 <code>#ref</code> 應為 {0, choice, 1#{1}|2#{1} 和 {2}}
jvm.inspection.test.failed.line.display.name=測試中失敗的行
jvm.inspections.source.to.sink.flow.display.name=不安全字串被傳遞至安全方法
jvm.inspections.junit5.converter.display.name=JUnit 4 測試可以為 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以為 JUnit 5 測試
jvm.inspections.junit5.converter.quickfix=遷移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=轉換斷言
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由於存在不相容的繼承者，類別 {0} 無法轉換為 JUnit 5: {1}
jvm.inspections.thread.run.display.name=呼叫 'Thread.run()'
jvm.inspections.serializable.class.without.serialversionuid.display.name=不帶 'serialVersionUID' 的可序列化類別
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字串用作安全參數
jvm.inspections.source.to.sink.flow.passed.unknown=未知字串用作安全參數
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unknown=未知字串返回自安全方法
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=將 ''{0}'' 標記為需要驗證
jvm.inspections.blocking.method.consider.unknown.context.blocking=考慮未知上下文阻塞
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=傳播安全註解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=從 ''{0}'' 傳播安全註解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=選擇要註解為安全的成員
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=註解除排除外的所有物件
propagated.from=標記為安全的原因:
propagated.to=要標記為安全的目標:
propagate.from.empty.text=此處將顯示標記為安全的原因
propagate.to.empty.text=此處將顯示要標記為安全的目標
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字串分配給安全變數
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字串分配給安全變數
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unknown=未知字串在安全上下文中使用
jvm.inspections.api.display.name=使用在設定的語言級別下不可用的 API
jvm.inspections.1.5.problem.descriptor=使用記錄為 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以來通用的 API，這可能會導致 JDK {0} 出現編譯問題。
jvm.inspections.1.8.problem.descriptor=預設{0, choice, 0#|1#方法|2#方法}不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.1.8.problem.single.descriptor=預設方法 ''{0}'' 不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=將 ''@Untainted'' 註解新增到 {0}
jvm.inspections.dependency.on.internal.display.name=對內部軟體套件的非法相依
inspection.message.illegal.dependency.module.doesn.t.export=非法相依: 模組 ''{0}'' 不匯出軟體套件 ''{1}''
jvm.inspections.test.frameworks.group.name=測試框架
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式錯誤的宣告
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下物件註解時忽略測試參數:
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 與 ''@{1}'' 組合
jvm.inspections.junit.malformed.repetition.number.descriptor=重複次數必須大於零
jvm.inspections.junit.malformed.extension.class.level.descriptor=應在類別級別註冊{0}
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=無法解析目標方法源: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必須在 'Arguments' 中包裝多個參數
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必須具有以下其中一種返回值類型: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不應有參數
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必須為 static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到將 ''{0}'' 轉換為 ''{1}'' 的隱式轉換
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重複的 'enum' 常數名稱
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=無法解析 'enum' 常數參照。
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定義值源
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必須恰好提供一種類型的輸入
jvm.inspections.junit.malformed.param.file.source.descriptor=無法解析檔案源: ''{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=沒有提供源，套件將為空
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應宣告參數 ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 的類型應為 ''{1}'' 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1} 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應宣告參數 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 的類型應為 ''{1}''，且不應宣告參數 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1} 且不應宣告參數 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 {4} 和 ''{5}''
jvm.inspections.junit.malformed.fix.method.signature=修復方法簽名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修復 ''{0}'' 方法簽名
jvm.inspections.junit.malformed.fix.field.signature=修正欄位簽名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 欄位簽名
jvm.inspections.junit3.super.teardown.display.name=未從 'finally' 塊呼叫 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未從 'finally' 塊呼叫 <code>#ref()</code> #loc
jvm.inspections.junit.assertequals.on.array.display.name=在陣列上呼叫了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在陣列上呼叫了 <code>#ref()</code> #loc
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
jvm.inspections.migrate.assertion.name=JUnit 斷言可以是 'assertThat()' 呼叫
jvm.inspections.migrate.assert.to.matcher.option=靜態匯入符合程序的方法
jvm.inspections.migrate.assert.to.matcher.description=斷言表達式 <code>#ref</code> 可被取代為 ''{0}'' 呼叫 #loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
jvm.inspections.junit.ignored.test.ignore.reason.option=只報告沒有原因的註解
jvm.inspections.junit.ignored.test.class.problem.descriptor=測試類別 ''{0}'' 已被{1, choice, 1#|2#無理由}忽略/停用 #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=測試方法 ''{0}()'' 已被{1, choice, 1#|2#無理由}忽略/停用 #loc
jvm.inspections.test.method.without.assertion.display.name=不帶斷言的測試方法
jvm.inspections.test.method.without.assertion.problem.descriptor=測試方法 <code>#ref()</code> 不包含斷言 #loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通建構函式的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=建構函式 <code>#ref()</code> 中的初始化邏輯，而不是 'setup()' 生命周期方法 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始設定式中的初始化邏輯，而不是 'setup()' 生命周期方法
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=開啟工具視窗以設定安全註解的傳播
jvm.inspections.test.case.in.product.source.display.name=產品源中的測試
jvm.inspections.test.case.in.product.source.problem.descriptor=測試用例 <code>#ref</code> 可能應被放置在測試源樹中 #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=測試方法 <code>#ref()</code> 可能應被放置在測試源樹中 #loc
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>#ref</code> 應為 {0}, {1}{2, choice, 0# 且無形參|1#, 無形參，且類型為 void}
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2}
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 類型應為 ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2} 且類型應為 ''{3}''
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2}, {3} 且類型應為 ''{4}''
jvm.inspections.junit.malformed.fix.class.signature=修復類別簽名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修復 ''{0}'' 類別簽名
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 無法向方法提供實參，因為方法沒有參數
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 無法向方法提供實參，因為方法具有不受支援的 ''{1}'' 類型的參數
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=此源不支持多個參數
jvm.inspections.junit4.converter.display.name=JUnit 3 測試可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> 可以轉換為 JUnit4 測試用例
jvm.inspections.junit4.converter.quickfix.name=轉換為 JUnit 4 測試用例
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 轉換為 JUnit 4，方法呼叫 {0} 可能會更改語意
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的遷移有副作用，將被刪除
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 將與其 super 方法發生名稱衝突
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 轉換為 JUnit 4，方法呼叫 {0} 將不編譯
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking